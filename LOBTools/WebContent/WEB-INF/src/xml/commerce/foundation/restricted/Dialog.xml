<?xml version="1.0" encoding="UTF-8"?>

<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<Definitions>

	<!---
		@keywords private
		
		A dialog that is draggable and placed in the middle of the windows
	-->
	<Window classDefinition="true" definitionName="cmc/foundation/Dialog" focustrap="true" initstage="defer" minHeight="150" modal="true" visible="false" x="${(this.immediateParent.width - this.width) / 2}" y="${(this.immediateParent.height - this.height) / 3}">
		<dependency localName="DefinitionUtil" moduleName="cmc/foundation/DefinitionUtil"/>

		<DragState drag_axis="both" drag_min_x="0" drag_min_y="0" name="dragger">
			<variable initialValue="${this.parent.height - this.height}" name="drag_max_y"/>
			<variable initialValue="${this.parent.width - this.width}" name="drag_max_x"/>
		</DragState>

        <method name="openWindow">
			<![CDATA[
			if (!this.isinited) {
				this.completeInstantiation();
				DefinitionUtil.completeCreateDefinitionChildren(this);
			}
			this.inherited(arguments);
			]]>
		</method>
        
        <!---
			@keywords private
		-->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			if (!this._definition) {
				this.postCreateDefinitionChildren();
			}
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<method name="postCreateDefinitionChildren">
			<![CDATA[

			]]>
		</method>
		<handler name="onmousedown">
			<![CDATA[
			this.dragger.setVariable("active", true);
			]]>
		</handler>
		<handler name="onmouseup">
			<![CDATA[
			this.dragger.setVariable("active", false);
			]]>
		</handler>
	</Window>
	
	<!--- @keywords private -->
	<Dialog classDefinition="true" definitionName="cmc/foundation/AlertDialog">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		
		<variable name="promptText" type="string" value=""/>
		<variable name="showOK" type="boolean" value="true"/>
		<variable name="showYes" type="boolean" value="false"/>
		<variable name="showNo" type="boolean" value="false"/>
		<variable name="showCancel" type="boolean" value="false"/>

		<AxisLayout axis="x" spacing="15"/>
		<Component imageSet="dialogWarningIcon" name="infoIcon"/>
		<TextComponent multiline="true" name="text" text="${this.classroot.promptText}" width="300"/>

		<Button name="cancelBtn" placement="leftFooter" text="${foundationResources.Singleton.simpleDialogCancel.string}" visible="${this.classroot.showCancel &amp;&amp; this.classroot.showNo}" primary="false">
			<handler name="onclick">
				<![CDATA[
				this.classroot.closeWindow();
				]]>
			</handler>
		</Button>
		<Component name="viewButtons" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="cancelBtn" text="${foundationResources.Singleton.simpleDialogCancel.string}" visible="${this.classroot.showCancel &amp;&amp; !this.classroot.showNo}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.classroot.closeWindow();
					]]>
				</handler>
			</Button>
			<Button name="noBtn" text="${foundationResources.Singleton.simpleDialogNo.string}" visible="${this.classroot.showNo}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.classroot.handleNo();
					this.classroot.closeWindow();
					]]>
				</handler>
			</Button>
			<Button isdefault="true" name="yesBtn" text="${foundationResources.Singleton.simpleDialogYes.string}" visible="${this.classroot.showYes}">
				<handler name="onclick">
					<![CDATA[
					this.classroot.handleYes();
					this.classroot.closeWindow();
					]]>
				</handler>
			</Button>
			<Button name="okBtn" text="${foundationResources.Singleton.simpleDialogOK.string}" visible="${this.classroot.showOK}">
				<handler name="onclick">
					<![CDATA[
					this.classroot.handleOK();
					this.classroot.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>

        <method args="alertText, callBackMethod" name="openAlertDialog">
			<![CDATA[
			this.openWindow();
			if (typeof (alertText) != "undefined") {
				this.setVariable("promptText", alertText);
			}
			if (typeof (callBackMethod) != "undefined") {
				this.callBackMethod = callBackMethod;
			}
			]]>
		</method>

        <method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			if (this.callBackMethod != undefined && this.callBackMethod != null) {
				this.callBackMethod();
			}
			]]>
		</method>

		<!---
			This method is called when the user selects the OK option.
		-->
		<method name="handleOK">
			<![CDATA[

			]]>
		</method>

		<!---
			This method is called when the user selects the Yes option.
		-->
		<method name="handleYes">
			<![CDATA[

			]]>
		</method>
		
		<!---
			This method is called when the user selects the No option.
		-->
		<method name="handleNo">
			<![CDATA[

			]]>
		</method>
	</Dialog>

	<!---
		The customer service error dialog, that will popup when the user try to fire a
		custom service on an object that has unsaved changes.
	-->	
	<AlertDialog definitionName="cmc/foundation/CustomServiceUnsavedDialog" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
	
		<method args="customService" name="openCustomServiceUnsavedDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("customServiceUnsavedDialogPrompt", [customService.displayName]));
			]]>
		</method>
	</AlertDialog>	

	<!---
		The client action error dialog, that will popup when the user try to perform a
		client action on an object that has unsaved changes.
	-->	
	<AlertDialog definitionName="cmc/foundation/ClientActionUnsavedDialog" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
	
		<method args="clientAction" name="openClientActionUnsavedDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("clientActionUnsavedDialogPrompt", [clientAction.displayName]));
			]]>
		</method>
	</AlertDialog>	
	
	<!---
		The close confirmation dialog. This dialog is used to prompt the user to save an object before closing it.
	-->
	<AlertDialog definitionName="cmc/foundation/CloseConfirmationDialog" showCancel="true" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		
		<variable name="closeObject" value="${null}"/>
		
		<!-- 
			Business Object Editor of the object to be closed
		 -->
		<variable name="oEditor" value="${null}"/>
		
		<!---
			Confirm that the specified object can be closed.
			@param cmc/foundation/ModelObject o: the object to be closed
		-->
		<method args="o" name="openCloseConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("saveConfirmationDialogText", [o.objectDisplayName]));
			this.closeObject = o;
			this.oEditor = o.model.oEditor;
			]]>
		</method>
		
		<!---
			Set the focus to Yes button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.closeObject = null;
			this.oEditor = null;
			]]>
		</method>
		
	    <!---
	    	Save and close the object.
	    -->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/CloseConfirmationDialog handleYes");
			this.closeObject.saveObject(false);
			this.closeObject.setVariable("open", false);
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
		
	    <!---
	    	Close the object without saving changes.
	    -->
		<method name="handleNo">
			<![CDATA[
			this.closeObject.closeObject();
			]]>
		</method>
	</AlertDialog>

	<!---
		The close confirmation dialog. This dialog is used to prompt the user to save an object before closing it even if the object has validation errors.
	-->
	<AlertDialog definitionName="cmc/foundation/CloseWithErrorConfirmationDialog" showCancel="true" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		
		<variable name="closeObject" value="${null}"/>
		
		<!-- 
			Business Object Editor of the object to be closed
		 -->
		<variable name="oEditor" value="${null}"/>
		
		<!---
			Confirm that the specified object can be closed.
			@param cmc/foundation/ModelObject o: the object to be closed
		-->
		<method args="o" name="openCloseWithErrorConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("closeWithErrorConfirmationText", [o.objectDisplayName]));
			this.closeObject = o;
			this.oEditor = o.model.oEditor;
			]]>
		</method>
		
		<!---
			Set the focus to Yes button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.closeObject = null;
			this.oEditor = null;
			]]>
		</method>
		
	    <!---
	    	Save and close the object.
	    -->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/CloseWithErrorConfirmationDialog handleYes");
			this.closeObject.saveObject(false);
			this.closeObject.setVariable("open", false);
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
		
	    <!---
	    	Close the object without saving changes.
	    -->
		<method name="handleNo">
			<![CDATA[
			this.closeObject.closeObject();
			]]>
		</method>
	</AlertDialog>

	<!---
		This dialog is used to prompt the user to save an object if there is a validation error before saving and closing
		the object. Close operation must wait until save operation is done. 
	-->                 
	<AlertDialog definitionName="cmc/foundation/SaveAndCloseConfirmationDialog" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
	
		<variable name="closeObject" value="${null}"/>
		
		<!-- 
			Business Object Editor of the object to be saved and closed
		 -->
		<variable name="oEditor" value="${null}"/>
		
		<!---
			Confirm that the specified object can be closed.
			@param cmc/foundation/ModelObject o: the object to be closed
		-->
		<method args="o" name="openSaveAndCloseConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("saveWithErrorConfirmationText", [o.objectDisplayName]));
			this.closeObject = o;
			this.oEditor = o.model.oEditor;
			]]>
		</method>
		
		<!---
			Set the focus to Yes button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.closeObject = null;
			this.oEditor = null;
			]]>
		</method>
		
	    <!---
	    	Save and close the object.
	    -->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/SaveAndCloseConfirmationDialog handleYes");
			this.closeObject.saveObject(false);
			this.closeObject.setVariable("open", false);
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>	  
	</AlertDialog>

	<!---
		The delete confirmation dialog. This dialog is used to prompt the user to confirm before deleting an object.
	-->
	<AlertDialog definitionName="cmc/foundation/DeleteConfirmationDialog" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
	
		<!---
			The object that is to be deleted.
		-->
		<variable name="deleteObject" value="${null}"/>
		
		<!-- 
			Business Object Editor of the object to be deleted
		 -->
		<variable name="oEditor" value="${null}"/>
		
		<!---
			Confirm that the specified object can be deleted
			@param cmc/foundation/ModelObject o: the object to be deleted
		-->
		<method args="o" name="openDeleteConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("deleteConfirmationDialogText", [o.objectDisplayName]));
			this.deleteObject = o;
			this.oEditor = o.model.oEditor;
			]]>
		</method>
		
		<!---
			Set the focus to Yes button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.deleteObject = null;
			this.oEditor = null;
			]]>
		</method>
		
	    <!---
	    	Delete the object.
	    -->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/DeleteConfirmationDialog handleYes");
			this.deleteObject.deleteObject();
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
	</AlertDialog>
	
	<!---
		This dialog is used to prompt a user to confirm the user will save an object even if the object has validation errors
	-->
	<AlertDialog definitionName="cmc/foundation/SaveWithErrorConfirmationDialog" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The object that is to be deleted.
		-->
		<variable name="saveObject" value="${null}"/>
		
		<!-- 
			Business Object Editor of the object to be saved
		-->
		<variable name="oEditor" value="${null}"/>
	
		<!---
			Confirm that the specified object can be deleted
			@param cmc/foundation/ModelObject o: the object to be deleted
		-->
		<method args="o" name="openSaveWithErrorConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("saveWithErrorConfirmationText", [o.objectDisplayName]));
			this.saveObject = o;
			this.oEditor = o.model.oEditor;
			]]>
		</method>
		
		<!---
			Set the focus to Yes button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.saveObject = null;
			this.oEditor = null;
			]]>
		</method>
		
		<!---
			Save the object.
		-->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/SaveWithErrorConfirmationDialog handleYes");
			this.saveObject.saveObject(false);
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
	</AlertDialog>

	<!---
		The refresh confirmation dialog. This dialog is used to prompt the user to confirm that changes can be discarded before a refresh.
	-->
	<AlertDialog definitionName="cmc/foundation/RefreshConfirmationDialog" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The object that is to be refreshed.
		-->
		<variable name="refreshObject" value="${null}"/>
		
		<!-- 
			Business Object Editor of the object to be refreshed
		 -->
		<variable name="oEditor" value="${null}"/>
		
		<!---
			Confirm that the specified object can be refreshed
			@param cmc/foundation/ModelObject o: the object to be refreshed
		-->
		<method args="o" name="openRefreshConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("refreshConfirmationDialogText", [o.objectDisplayName]));
			this.refreshObject = o;
			this.oEditor = o.model.oEditor;
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.refreshObject = null;
			this.oEditor = null;
			]]>
		</method>
		
	    <!---
	    	Refresh the object.
	    -->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/RefreshConfirmationDialog handleYes");
			this.refreshObject.refreshObject();
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
	</AlertDialog>

	<!---
		The save open objects confirmation dialog. This dialog is used to prompt the user to save objects 
	-->
	<Dialog definitionName="cmc/foundation/SaveOpenObjectsDialog" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="ModelUtil" moduleName="cmc/foundation/ModelUtil"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The model.
		-->
		<variable name="model"/>
		<!---
			Array of objects that have unsaved changes.
		-->
		<variable name="unsavedObjects" value="${null}"/>
		<!---
			Array of objects that have errors
		-->
		<variable name="errorUnsavedObjects" value="${null}"/>
		
		<!---
			Open the save open objects dialog.
			@param cmc/foundation/Model m: client side model
		-->
		<method args="m" name="openSaveOpenObjectsDialog">
			<![CDATA[
			this.openWindow();
			this.model = m;
			this.unsavedObjects = [];
			this.closeObjects = [];
			this.errorUnsavedObjects = [];
			for (var i = 0; i < this.model.openObjects.length; i++) {
				var o = this.model.openObjects[i];
				if (o.openGroupDirty) {
					if (o.hasErrors(true)) {
						this.errorUnsavedObjects.push(o);
					}
					else {
						this.unsavedObjects.push(o);
					}
				}
				else {
					this.closeObjects.push(o);
				}
			}
			if (this.errorUnsavedObjects.length > 0) {
				this.contentArea.errorObjectAreaTitle.setVariable("visible", true);
				this.contentArea.errorObjectsArea.setVariable("visible", true);
				this.contentArea.errorPrompt.setVariable("visible", true);
				this.contentArea.errorObjectsArea.objectCheckboxes.setObjects(this.errorUnsavedObjects);
			}
			else {
				this.contentArea.errorObjectAreaTitle.setVariable("visible", false);
				this.contentArea.errorObjectsArea.setVariable("visible", false);
				this.contentArea.errorPrompt.setVariable("visible", false);
			}
			if (this.unsavedObjects.length > 0) {
				this.contentArea.unsavedObjectAreaTitle.setVariable("visible", true);
				this.contentArea.objectsArea.setVariable("visible", true);
				this.contentArea.prompt.setVariable("visible", true);
				this.contentArea.objectsArea.objectCheckboxes.setObjects(this.unsavedObjects);
			}
			else {
				this.contentArea.unsavedObjectAreaTitle.setVariable("visible", false);
				this.contentArea.objectsArea.setVariable("visible", false);
				this.contentArea.prompt.setVariable("visible", false);
			}
			]]>
		</method>
		
		<!---
			Set the focus to OK button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.footerView.saveOkBtn);
			]]>
		</method>
		
		<!---
			Close the save open objects dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.contentArea.objectsArea.objectCheckboxes.setObjects([]);
			this.contentArea.errorObjectsArea.objectCheckboxes.setObjects([]);
			this.unsavedObjects = null;
			this.errorUnsavedObjects = null;
			this.closeObjects = null;
			this.contentArea.errorObjectsArea.setVariable("visible", false);
			this.contentArea.errorPrompt.setVariable("visible", false);
			this.contentArea.objectsArea.setVariable("visible", false);
			this.contentArea.prompt.setVariable("visible", false);
			this.inherited(arguments);
			this.model = null;
			]]>
		</method>

		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.model.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Save the selected objects and discard changes for the unselected objects.
		-->
		<method name="handleOk">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/SaveOpenObjectsDialog handleOk");
			this.model.lock();
			var saveObjects = [];
			if (this.unsavedObjects != null) {
				for (var i = 0; i < this.unsavedObjects.length; i++) {
					var o = this.unsavedObjects[i];
					var save = this.contentArea.objectsArea.objectCheckboxes.isSelected(o);
					if (save) {
						saveObjects.push(o);
					}
					else {
						o.closeObject();
					}
				}
			}
			if (this.errorUnsavedObjects != null) {
				for (var i = 0; i < this.errorUnsavedObjects.length; i++) {
					var o = this.errorUnsavedObjects[i];
					var save = this.contentArea.errorObjectsArea.objectCheckboxes.isSelected(o);
					if (save) {
						saveObjects.push(o);
					}
					else {
						o.closeObject();
					}
				}
			}
			ModelUtil.Singleton.sortObjectsBySaveOrder(saveObjects);
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.appendMsg("#objects=" + saveObjects.length);
			for (var i = 0; i < saveObjects.length; i++) {
				var o = saveObjects[i];
				o.saveObject(false, false);
				o.setVariable("open", false);
			}
			if (this.closeObjects != null) {
				for (var i = 0; i < this.closeObjects.length; i++) {
					this.closeObjects[i].closeObject();
				}
			}
			this.model.unlock();
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
		
		<!---
			Select all of the saved objects.
		-->
		<method args="type" name="selectAll">
			<![CDATA[
			if (type == "unsaved") {
				this.contentArea.objectsArea.objectCheckboxes.selectAll();
			}
			if (type == "error") {
				this.contentArea.errorObjectsArea.objectCheckboxes.selectAll();
			}
			]]>
		</method>
		
		<!---
			Deselect all of the objects.
		-->
		<method args="type" name="deselectAll">
			<![CDATA[
			if (type == "unsaved") {
				this.contentArea.objectsArea.objectCheckboxes.deselectAll();
			}
			if (type == "error") {
				this.contentArea.errorObjectsArea.objectCheckboxes.deselectAll();
			}
			]]>
		</method>

		<AxisLayout axis="x" spacing="15"/>
		<Component imageSet="dialogWarningIcon" name="infoIcon"/>		
		<Component name="contentArea">

			<AxisLayout axis="y" spacing="3"/>

			<TextComponent name="unsavedObjectAreaTitle" text="${foundationResources.Singleton.saveUnsavedObjectsTitle.string}"/>
			<TextComponent multiline="true" name="prompt" text="${foundationResources.Singleton.saveUnsavedObjectsPrompt.string}" width="300"/>
			<Component name="objectsArea">
				<AxisLayout axis="y" spacing="5"/>
				<Component>
					<AxisLayout axis="x" spacing="5"/>
					<Button text="${foundationResources.Singleton.saveOpenObjectsDialogSelectAll.string}" primary="false">
						<handler name="onclick">
							<![CDATA[
							this.parent.parent.parent.parent.selectAll("unsaved");
							]]>
						</handler>
					</Button>
					<Button text="${foundationResources.Singleton.saveOpenObjectsDialogDeselectAll.string}" primary="false">
						<handler name="onclick">
							<![CDATA[
							this.parent.parent.parent.parent.deselectAll("unsaved");
							]]>
						</handler>
					</Button>
				</Component>
				<ObjectSelectionList height="100" name="objectCheckboxes" width="${this.parent.parent.prompt.width}"/>
			</Component>	

			<TextComponent name="errorObjectAreaTitle" text="${foundationResources.Singleton.saveObjectWithValidationErrorTitle.string}"/>
			<TextComponent multiline="true" name="errorPrompt" text="${foundationResources.Singleton.saveObjectWithValidationErrorPrompt.string}" width="300"/>
			<Component name="errorObjectsArea">
				<AxisLayout axis="y" spacing="5"/>
				<Component>
					<AxisLayout axis="x" spacing="5"/>
					<Button text="${foundationResources.Singleton.saveOpenObjectsDialogSelectAll.string}" primary="false">
						<handler name="onclick">
							<![CDATA[
							this.parent.parent.parent.parent.selectAll("error");
							]]>
						</handler>
					</Button>
					<Button text="${foundationResources.Singleton.saveOpenObjectsDialogDeselectAll.string}" primary="false">
						<handler name="onclick">
							<![CDATA[
							this.parent.parent.parent.parent.deselectAll("error");
							]]>
						</handler>
					</Button>
				</Component>
				<ObjectSelectionList height="100" name="objectCheckboxes" width="${this.parent.parent.prompt.width}"/>
			</Component>
		</Component>

		<Component name="footerView" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="saveCancelBtn" text="${foundationResources.Singleton.saveOpenObjectsDialogCancel.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button isdefault="true" name="saveOkBtn" text="${foundationResources.Singleton.saveOpenObjectsDialogOk.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleOk();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>
	</Dialog>

	<!---
		The save open objects confirmation dialog. This dialog is used to prompt the user to save objects 
	-->
	<Dialog definitionName="cmc/foundation/SaveOpenObjectsWithErrorDialog" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		
		<!--- The model -->
		<variable name="model"/>
		<!---
			Array of unsaved objects that have validation errors
		-->
		<variable name="errorUnsavedObjects" value="${null}"/>
		<!---
			Array of unsaved objects that do not have validation errors
		-->
		<variable name="unsavedObjects" value="${null}"/>
		<!---
			Open the save open objects dialog.
			@param cmc/foundation/Model m: client side model
		-->
		<method args="m" name="openSaveOpenObjectsWithErrorDialog">
			<![CDATA[
			this.openWindow();
			this.model = m;
			this.errorUnsavedObjects = [];
			this.unsavedObjects = [];
			for (var i = 0; i < this.model.openObjects.length; i++) {
				var o = this.model.openObjects[i];
				if (o.openGroupDirty) {
					if (o.hasErrors(true)) {
						this.errorUnsavedObjects.push(o);
					}
					else {
						this.unsavedObjects.push(o);
					}
				}
			}
			this.contentArea.objectsArea.objectCheckboxes.setObjects(this.errorUnsavedObjects);
			]]>
		</method>
		
		<!---
			Set the focus to OK button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.footerView.saveOkBtn);
			]]>
		</method>
		
		<!---
			Close the save open objects dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.contentArea.objectsArea.objectCheckboxes.setObjects([]);
			this.errorUnsavedObjects = null;
			this.unsavedObjects = null;
			this.inherited(arguments);
			this.model = null;
			]]>
		</method>

		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.model.oEditor.restoreFocus();
			}
			]]>
		</method>

		<!---
			Save the selected objects and discard changes for the unselected objects.
		-->
		<method name="handleOk">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/SaveOpenObjectsWithErrorDialog handleOk");
			for (var i = 0; i < this.errorUnsavedObjects.length; i++) {
				var o = this.errorUnsavedObjects[i];
				var save = this.contentArea.objectsArea.objectCheckboxes.isSelected(o);
				if (save) {
					this.unsavedObjects.push(o);
				}
			}
			this.model.saveOpenObjects(this.unsavedObjects);
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
		
		<!---
			Select all of the unsaved objects.
		-->
		<method name="selectAll">
			<![CDATA[
			this.contentArea.objectsArea.objectCheckboxes.selectAll();
			]]>
		</method>
		
		<!---
			Deselect all of the objects.
		-->
		<method name="deselectAll">
			<![CDATA[
			this.contentArea.objectsArea.objectCheckboxes.deselectAll();
			]]>
		</method>

		<AxisLayout axis="x" spacing="15"/>
		<Component imageSet="dialogWarningIcon" name="infoIcon"/>		
		<Component name="contentArea">
			<TextComponent multiline="true" name="prompt" text="${foundationResources.Singleton.saveObjectWithValidationErrorPrompt.string}" width="300"/>
			<Component name="objectsArea" y="${this.parent.prompt.y + this.parent.prompt.height}">
				<AxisLayout axis="y" spacing="5"/>
				<Component>
					<AxisLayout axis="x" spacing="5"/>
					<Button text="${foundationResources.Singleton.saveOpenObjectsDialogSelectAll.string}" primary="false">
						<handler name="onclick">
							<![CDATA[
							this.parent.parent.parent.parent.selectAll();
							]]>
						</handler>
					</Button>
					<Button text="${foundationResources.Singleton.saveOpenObjectsDialogDeselectAll.string}" primary="false">
						<handler name="onclick">
							<![CDATA[
							this.parent.parent.parent.parent.deselectAll();
							]]>
						</handler>
					</Button>
				</Component>
				<ObjectSelectionList height="100" name="objectCheckboxes" width="${this.parent.parent.prompt.width}"/>
			</Component>
		</Component>

		<Component name="footerView" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="saveCancelBtn" text="${foundationResources.Singleton.saveOpenObjectsDialogCancel.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button isdefault="true" name="saveOkBtn" text="${foundationResources.Singleton.saveOpenObjectsDialogOk.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleOk();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>
	</Dialog>
	
	
	<!---
		@keywords private
		
		Base class for the multiple discard confirmation dialog. The dialog is used to prompt the user for confirmation when
		an action has been triggered that will cause the changes to multiple objects to be lost.
	-->
	<AlertDialog classDefinition="true" definitionName="cmc/foundation/ListAlert">
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<!---
			Open the multiple discard confirmation dialog.
			@param array unsavedObjects: array of unsaved objects
		-->
		<method args="objects" name="openListAlertDialog">
			<![CDATA[
			this.openWindow();
			this.objectsArea.objectItems.setObjects(objects);
			]]>
		</method>
		
		<!---
			Set the focus to Yes button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>
		
		<!---
			Close multiple discard confirmation dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.objectsArea.objectItems.setObjects([]);
			this.inherited(arguments);
			]]>
		</method>
			
		<Component clip="true" ignoreLayout="true" name="objectsArea" x="${this.parent.text.x}" y="${this.parent.text.y + this.parent.text.height + 5}">
			
			<!-- In case the number of objects to discard are too much for the dialog, create a container that can scroll so dialog doesn't get too long -->
			<ObjectItemList height="150" name="objectItems" width="${this.parent.parent.text.width}"/>
		</Component>
	</AlertDialog>
		
	<!---
		The multiple delete confirmation dialog. This dialog is used to prompt the user to confirm before deleting multiple objects.
	-->
	<ListAlert definitionName="cmc/foundation/MultipleDeleteConfirmationDialog" promptText="${foundationResources.Singleton.multipleDeleteConfirmationDialogText.string}" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		
		<!---
			The array of objects that are to be deleted.
		-->
		<variable name="deleteObjects" value="${null}"/>
		
		<!-- 
			Business Object Editor of the objects to be deleted
		 -->
		<variable name="oEditor" value="${null}"/>
		
		<!---
			Confirm that the specified objects can be deleted
			@param array objects: the objects to be deleted
		-->
		<method args="objects" name="openMultipleDeleteConfirmationDialog">
			<![CDATA[
			this.deleteObjects = objects;
			this.oEditor = objects[0].model.oEditor;
			this.openListAlertDialog(this.deleteObjects);
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close multiple delete confirmation dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.deleteObjects = null;
			this.oEditor = null;
			]]>
		</method>
		
	    <!---
	    	Delete the objects.
	    -->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/MultipleDeleteConfirmationDialog handleYes");
			for (var i = 0; i < this.deleteObjects.length; i++) {
				this.deleteObjects[i].deleteObject();
			}
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
	</ListAlert>

	<!---
		Refresh all confirmation dialog. This dialog is used to prompt when there are unsaved objects and the "refresh all" action has been requested.
	-->
	<ListAlert definitionName="cmc/foundation/RefreshAllConfirmationDialog" promptText="${foundationResources.Singleton.multipleDiscardConfirmationDialogText.string}" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
	
		<!---
			The model.
		-->
		<variable name="model"/>
		<!---
			Refresh object.
		-->
		<variable name="refreshObject" value="${null}"/>
		<!---
			Child object definitions to be reloaded.
		-->
		<variable name="oDefs" value="${null}"/>
		<!---
			Paging direction indicator.
		-->
		<variable name="paging" value="${null}"/>
		
		<!---
			Open the refresh all confirmation dialog.
			@param cmc/foundation/Model m: client side model
			@param array unsavedObjects: array of unsaved objects
			@param cmc/foundation/ModelObject ro: refresh object
			@param [cmc/foundation/ObjectDefinition] defs: array of child object definitions to be reloaded
			@param string p: Indicates that the "next" or "previous" page of child objects should be loaded.
		-->
		<method args="m, unsavedObjects, ro, defs, p" name="openRefreshAllConfirmationDialog">
			<![CDATA[
			if (typeof(ro) == "undefined") ro = null;
			if (typeof(defs) == "undefined") defs = null;
			if (typeof(p) == "undefined") p = null;
			this.model = m;
			this.refreshObject = ro;
			this.paging = p;
			this.oDefs = defs;
			this.openListAlertDialog(unsavedObjects);
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.model.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close refresh all confirmation dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.model = null;
			this.refreshObject = null;
			this.paging = null;
			this.oDefs = null;
			]]>
		</method>
		
		<!---
			Trigger refresh all.
		-->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/RefreshAllConfirmationDialog handleYes");
			if (this.refreshObject != null) {
				this.model.refreshDescendants(this.refreshObject, false, this.oDefs, this.paging);
			}
			else {
				this.model.refreshAll();
			}
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
	</ListAlert>
	
	<!---
		Change store confirmation dialog. This dialog is used to prompt when there are unsaved objects and the "change store" action has been requested.
	-->
	<ListAlert definitionName="cmc/foundation/ChangeStoreConfirmationDialog" promptText="${foundationResources.Singleton.multipleDiscardConfirmationDialogText.string}" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>

		<!---
			The store selection handler. This object must have a changeStore method.
		-->
		<variable name="storeSelectionHandler"/>
		<!---
			The new store.
		-->
		<variable name="newStore"/>
		
		<!---
			The unsavedObjects within the current store
		-->
		<variable name="unsavedObjects"/>
		
		<!---
			Open the change store confirmation dialog.
			@param Object handler: store selection handler
			@param cmc/foundation/Store store: the new store
			@param array unsavedObjects: array of unsaved objects
		-->
		<method args="handler, store, unsavedObjects" name="openChangeStoreConfirmationDialog">
			<![CDATA[
			this.storeSelectionHandler = handler;
			this.newStore = store;
			this.unsavedObjects = unsavedObjects;
			this.openListAlertDialog(unsavedObjects);
			]]>
		</method>
		
		<!---
			Close change store confirmation dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.storeSelectionHandler = null;
			this.unsavedObjects = null;
			this.newStore = false;
			]]>
		</method>

		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null && this.unsavedObjects.length > 0) {
				this.unsavedObjects[0].model.oEditor.restoreFocus();
			}
			]]>
		</method>

		<!---
			Trigger change store.
		-->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/ChangeStoreConfirmationDialog handleYes");
			this.storeSelectionHandler.changeStore(this.newStore, false);
			this.restoreFocusView = null;
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
		
		<!---
			Stop the change store action.
		-->
		<method name="handleNo">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/ChangeStoreConfirmationDialog handleNo");
			if (this.storeSelectionHandler.cancelChangeStore) {
				this.storeSelectionHandler.cancelChangeStore();
			}
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
	</ListAlert>
	
	<!---
		@keywords private

		This class implements the dialog that is opened when the user selects a workspace task to
		work on while opened tools in Management Center have unsaved changes. It has the options of
		disregarding the changes and change to the task, and cancel the action.
	-->
	<AlertDialog definitionName="cmc/foundation/ChangeTaskConfirmationDialog" promptText="${foundationResources.Singleton.changeTaskWithUnsavedChangesPrompt.string}" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The task selection handler. This object must have a changeTask method.
		-->
		<variable name="taskSelectionHandler"/>
		<!---
			The new task.
		-->
		<variable name="newTask"/>
		<!--- 
			This attribute indicates whether the taskSelectionHandler should be reset or not.
		-->
		<variable name="isCancelAction" type="boolean" value="true"/>
		
		<!---
			@keywords private
			This method opens this dialog to warn the user that tools in Management Center have unsaved
			changes.
			@param Object handler: task selection handler
			@param task: the new task
		-->
		<method args="handler, task" name="openChangeTaskConfirmationDialog">
			<![CDATA[
			this.taskSelectionHandler = handler;
			this.newTask = task;
			this.openWindow();
			]]>
		</method>
		
		<!---
			@keywords private
			Set the focus to No button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.noBtn);
			]]>
		</method>

		<!---
			@keywords private
			This method closes this dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			if (this.taskSelectionHandler != null && this.taskSelectionHandler.cancelChangeTask && this.isCancelAction) {
				this.taskSelectionHandler.cancelChangeTask();
			}
			this.inherited(arguments);
			this.taskSelectionHandler = null;
			this.newTask = null;
			this.isCancelAction = true;
			]]>
		</method>
		
		<!--- 
			@keywords private 
			Trigger change task.
		-->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/ChangeTaskConfirmationDialog handleYes");
			this.taskSelectionHandler.changeTask(this.newTask, false);
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
	</AlertDialog>
	
	<!---
		@keywords private

		This class implements the dialog that is opened when the workspace task selection option is enabled during click to edit
		and there are no workspace TODO tasks to select from. In this case, user has the options of working in the approved content or canceling the action.
	-->
	<AlertDialog definitionName="cmc/foundation/WorkOnApprovedContentDialog" promptText="${foundationResources.Singleton.workOnApprovedContentPrompt.string}" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The work on approved content selection handler. This object must have a workOnApprovedContent method.
		-->
		<variable name="workOnApprovedContentHandler"/>

		<!--- 
			This attribute indicates whether the workOnApprovedContentHandler should be reset or not.
		-->
		<variable name="isCancelAction" type="boolean" value="true"/>
		
		<!---
			@keywords private
			This method opens this dialog to ask user whether they want to work on approved content context
			changes.
			@param Object handler: work on approved content selection handler
		-->
		<method args="handler" name="openWorkOnApprovedContentDialog">
			<![CDATA[
			this.workOnApprovedContentHandler = handler;
			this.openWindow();
			]]>
		</method>
		
		<!---
			@keywords private
			Set the focus to No button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.noBtn);
			]]>
		</method>

		<!---
			@keywords private
			This method closes this dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			if (this.workOnApprovedContentHandler != null && this.workOnApprovedContentHandler.cancelWorkOnApprovedContent && this.isCancelAction) {
				this.workOnApprovedContentHandler.cancelWorkOnApprovedContent();
			}
			this.inherited(arguments);
			this.workOnApprovedContentHandler = null;
			this.isCancelAction = true;
			]]>
		</method>

		<!--- 
			@keywords private 
			Trigger work on approved content.
		-->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("WorkOnApprovedContentDialog handleYes");
			this.workOnApprovedContentHandler.workOnApprovedContent();
			this.isCancelAction = false;
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
	</AlertDialog>
	
	<!---
		This dialog is used to prompt the user when the file they have selected using the {@link cmc/foundation/PropertyFileUploader file upload widget} is too large 
		to be uploaded. 
	-->                 
	<AlertDialog definitionName="cmc/foundation/FileTooLargeDialog" showCancel="false" showNo="false" showOK="true" showYes="false" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>		
		<!---
			@keywords private 
			This method opens an error dialog to notify the user that the selected file is too large to be uploaded.
			@param string fileName The file that is too large for the widget. 
			@param size maxSize The allowable maximum file size for files being uploaded in bytes. This is defined by {@link cmc/foundation/ObjectDefinition#maximumFileSize}.			
		-->
		<method args="fileName, maxSize" name="openFileTooLargeDialog">
			<![CDATA[
			this.openWindow();
			var valInMB = Math.round(maxSize / 1048576 * 10) / 10;
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("fileUploaderExceedMaximumSize", [fileName, valInMB]));
			]]>
		</method>	
	</AlertDialog>
	
	<!---
		This dialog is used to prompt the user when the file they have selected using the {@link cmc/foundation/PropertyFileUploader file upload widget} is empty. 		
	-->                 
	<AlertDialog definitionName="cmc/foundation/FileEmptyDialog" showCancel="false" showNo="false" showOK="true" showYes="false" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>		
		
		<!---
			@keywords private 
			This method opens an error dialog to notify the user that the selected file is empty.
			@param string fileName The file that is too large for the widget. 			
		-->
		<method args="fileName" name="openFileEmptyDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.fileEmpty.string);
			]]>
		</method>		
	</AlertDialog>

	<!---
		Store preview confirmation dialog. This dialog is used to prompt the user when there are unsaved objects and the 
		user clicked on the store preview toolbar button.
	-->
	<ListAlert definitionName="cmc/foundation/StorePreviewConfirmationDialog" promptText="${foundationResources.Singleton.storePreviewIgnoreChangesConfirmationDialogText.string}" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="StorePreviewDialog" moduleName="cmc/foundation/StorePreviewDialog"/>
		<dependency localName="CallbackUtil" moduleName="cmc/foundation/CallbackUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		
		<!---
			The business object editor.
		-->
		<variable name="oEditor"/>
		<!---
			The name value pair of preview context parameters.
		-->
		<variable name="previewContext"/>
		<!---
			Open the confirmation dialog with the list of unsaved objects.
			@param cmc/foundation/BusinessObjectEditor boe: business object editor
			@param array unsavedObjects: array of unsaved objects
			@param Object contextParam: a map of name value pair context parameters.
		-->
		<method args="boe, unsavedObjects, contextParams" name="openStorePreviewConfirmationDialog">
			<![CDATA[
			this.oEditor = boe;
			this.previewContext = contextParams;
			this.openListAlertDialog(unsavedObjects);
			]]>
		</method>
		
		<!---
			Close confirmation dialog with the list of all unsaved objects.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.oEditor = null;
			this.previewContext = null;
			]]>
		</method>
		
		<!---
			Opens the store preview dialog, using deferred callback to handle modal-stack properly
		-->
		<method name="handleYes">
			<![CDATA[
			if (typeof (this.openStorePreviewDialogDel) == "undefined") {
				this.openStorePreviewDialogDel = new EventHandler.Class(this, "openStorePreviewDialog");
			}
			CallbackUtil.Singleton.addDeferredCallback(this.openStorePreviewDialogDel, {
				boe: this.oEditor,
				contextParams: this.previewContext
			}, CallbackUtil.Singleton.PRIORITY_FOREGROUND);
			]]>
		</method>
		
		<!---
			Opens the store preview dialog.
			@param object args: object parameter that contains the business object editor and context parameters.
		-->
		<method args="args" name="openStorePreviewDialog">
			<![CDATA[
			var boe = args.boe;
			var contextParams = args.contextParams;
			StorePreviewDialog.Singleton.openStorePreviewDialog(boe, contextParams);
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this.openStorePreviewDialogDel) {
				this.openStorePreviewDialogDel.disconnectAll();
				delete this.openStorePreviewDialogDel;
			}
			this.inherited(arguments);
			]]>
		</method>
	</ListAlert>
	
	<!---
		@keywords private
		The save detected unsaved objects confirmation dialog. 
		This dialog prompts the user to save objects on regular basis.
	-->
	<Dialog definitionName="cmc/foundation/SaveDetectedUnsavedObjectsDialog" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="SingletonRegistry" moduleName="cmc/foundation/SingletonRegistry"/>
		<dependency localName="ToolsController" moduleName="cmc/shell/ToolsController"/>
		<dependency localName="ModelUtil" moduleName="cmc/foundation/ModelUtil"/>
		<dependency localName="Timer" moduleName="cmc/foundation/Timer"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<dependency localName="Logger" moduleName="cmc/shell/Logger"/>
		<!---
			Array of objects that have unsaved changes.
		-->
		<variable name="unsavedObjects" value="${null}"/>
		
		<!---
			Open the save open objects dialog.
			@param cmc/foundation/ModelObject objects: client side model objects
		-->
		<method args="objects" name="openSaveDetectedUnsavedObjectsDialog">
			<![CDATA[
			this.openWindow();
			this.unsavedObjects = [];
			for (var i = 0; i < objects.length; i++) {
				var o = objects[i];
				this.unsavedObjects.push(o);
			}
			this.contentArea.objectsArea.objectCheckboxes.setObjects(this.unsavedObjects);
			]]>
		</method>
		
		<!---
			Set the focus to OK button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.footerView.saveOkBtn);
			]]>
		</method>
		
		<!---
			Close the save open objects dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.contentArea.objectsArea.objectCheckboxes.setObjects([]);
			this.unsavedObjects = null;
			this.inherited(arguments);
			Timer.resetTimer(ModelUtil.Singleton.detectUnsavedObjectsDel, ModelUtil.Singleton.detectUnsavedObjectsInterval);
			if (Logger.Singleton.enabled) {
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/SaveDetectedUnsavedObjectsDialog", "closeWindow", "Reset interval to " + ModelUtil.Singleton.detectUnsavedObjectsInterval);
			}
			]]>
		</method>
		
		<!---
			Save the selected objects.
		-->
		<method name="handleOk">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/SaveDetectedUnsavedObjectsDialog handleOk");
			if (typeof (ToolsController.Singleton) != 'undefined') {
				for (var i = 0; i < ToolsController.Singleton.toolList.length; i++) {
					var tool = SingletonRegistry.toolPanesWidget.childComponents[SingletonRegistry.toolPanesWidget.findPane(ToolsController.Singleton.toolList[i])];
					if (tool.model) {
						tool.model.lock();
					}
				}
			}
			var saveObjects = [];
			if (this.unsavedObjects != null) {
				for (var i = 0; i < this.unsavedObjects.length; i++) {
					var o = this.unsavedObjects[i];
					var save = this.contentArea.objectsArea.objectCheckboxes.isSelected(o);
					if (save) {
						saveObjects.push(o);
					}
				}
			}
			ModelUtil.Singleton.sortObjectsBySaveOrder(saveObjects);
			for (var i = 0; i < saveObjects.length; i++) {
				var o = saveObjects[i];
				o.saveObject(false, false);
			}
			if (typeof (ToolsController.Singleton) != 'undefined') {
				for (var i = 0; i < ToolsController.Singleton.toolList.length; i++) {
					var tool = SingletonRegistry.toolPanesWidget.childComponents[SingletonRegistry.toolPanesWidget.findPane(ToolsController.Singleton.toolList[i])];
					if (tool.model) {
						tool.model.unlock();
					}
				}
			}
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>

		<AxisLayout axis="x" spacing="15"/>
		<Component imageSet="dialogWarningIcon" name="infoIcon"/>		
		<Component name="contentArea">

			<AxisLayout axis="y" spacing="3"/>

			<TextComponent name="unsavedObjectAreaTitle" text="${foundationResources.Singleton.saveUnsavedObjectsTitle.string}"/>
			<TextComponent multiline="true" name="prompt" text="${foundationResources.Singleton.saveSystemDetectedUnsavedObjectsPrompt.string}" width="300"/>
			<Component name="objectsArea">
				<AxisLayout axis="y" spacing="5"/>
				<ObjectSelectionList height="100" name="objectCheckboxes" width="${this.parent.parent.prompt.width}"/>
			</Component>	
		</Component>

		<Component name="footerView" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="saveCancelBtn" text="${foundationResources.Singleton.saveOpenObjectsDialogCancel.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button isdefault="true" name="saveOkBtn" text="${foundationResources.Singleton.saveOpenObjectsDialogOk.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleOk();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>
	</Dialog>
	
	<!---
		@keywords private
		List of objects.
	-->
	<FocusableComponent classDefinition="true" definitionName="cmc/foundation/ObjectItemList">
		<dependency localName="ObjectTextItem" moduleName="cmc/foundation/ObjectTextItem"/>
		<!---
			List of objects.
		-->
		<variable name="objectItems" value="${[]}"/>
		<!---
			The index of the current object.
		-->
		<variable name="currentObjectIndex" type="number" value="${-1}"/>
		<!---
			Indicates that the list has focus.
		-->
		<variable name="hasFocus" type="boolean" value="false"/>
		
		<!---
			Set the array of objects.
			@param [cmc/foundation/ModelObject] newObjects: array of model objects
		-->
		<method args="newObjects" name="setObjects">
			<![CDATA[
			for (var i = 0; i < this.objectItems.length; i++) {
				this.objectItems[i].setVariable("o", null);
				this.objectItems[i].setVariable("visible", false);
			}
			for (var i = 0; i < newObjects.length; i++) {
				if (i < this.objectItems.length) {
					this.objectItems[i].setVariable("o", newObjects[i]);
					this.objectItems[i].setVariable("visible", true);
				}
				else {
					this.objectItems.push(new ObjectTextItem.Class(this.borderedView.clippedContent.content, {
						o: newObjects[i],
						focusable: false
					}));
				}
			}
			if (newObjects.length > 0) {
				this.currentObjectIndex = 0;
			}
			else {
				this.currentObjectIndex = -1;
			}
			this.updateHilite();
			this.updateScroll();
			]]>
		</method>
		
		<!---
			Handle onfocus event.
		-->
		<handler name="onfocus">
			<![CDATA[
			this.hasFocus = true;
			this.updateHilite();
			]]>
		</handler>
		
		<!---
			Handle onblur event.
		-->
		<handler name="onblur">
			<![CDATA[
			this.hasFocus = false;
			this.updateHilite();
			]]>
		</handler>
		
		<!---
			Update the background color of the highlighted object.
		-->
		<method name="updateHilite">
			<![CDATA[
			for (var i = 0; i < this.objectItems.length; i++) {
				var c = this.bgcolor;
				if (this.hasFocus && this.currentObjectIndex == i) {
					c = this.style.hilitecolor;
				}
				this.objectItems[i].setVariable("bgcolor", c);
			}
			]]>
		</method>

		<!---
			Update the scroll to ensure that the highlighted object is visible.
		-->
		<method name="updateScroll">
			<![CDATA[
			var item = this.getObjectItem(this.currentObjectIndex);
			if (item != null) {
				var clipView = this.borderedView.clippedContent;
				var itemTop = item.getVariableRelative("y", clipView);
				var itemBottom = itemTop + item.height;
				if (itemTop < 0) {
					this.borderedView.vScroll.step(Math.floor(itemTop / this.borderedView.vScroll.stepsize));
				}
				else if (itemBottom > clipView.height) {
					this.borderedView.vScroll.step(Math.ceil((itemBottom - clipView.height) / this.borderedView.vScroll.stepsize));
				}
			}
			]]>
		</method>

		<!---
			Returns the object item at the specified index. If no such object exists, then this method returns
			null.
			@param integer index: the object index
		-->
		<method args="index" name="getObjectItem">
			<![CDATA[
			var item = null;
			if (index >= 0 && index < this.objectItems.length && this.objectItems[index].visible) {
				item = this.objectItems[index];
			}
			return item;
			]]>
		</method>

		<!---
			Sets the current item.
			@param cmc/foundation/ObjectTextItem item: the object item
		-->
		<method args="item" name="setCurrentItem">
			<![CDATA[
			if (item.visible) {
				for (var i = 0; i < this.objectItems.length; i++) {
					if (this.objectItems[i] == item) {
						this.currentObjectIndex = i;
						this.updateHilite();
						break;
					}
				}
			}
			]]>
		</method>

		<!---
			Handle key down event.
		-->
		<handler args="k" name="onkeydown">
			<![CDATA[
			if (k == 38) {
				var item = this.getObjectItem(this.currentObjectIndex - 1);
				if (item != null) {
					this.currentObjectIndex--;
					this.updateHilite();
					this.updateScroll();
				}
			}
			else if (k == 40) {
				var item = this.getObjectItem(this.currentObjectIndex + 1);
				if (item != null) {
					this.currentObjectIndex++;
					this.updateHilite();
					this.updateScroll();
				}
			}
			else if (k == 37) {
				this.borderedView.hScroll.step(-1);
			}
			else if (k == 39) {
				this.borderedView.hScroll.step(1);
			}
			]]>
		</handler>
		
		<BorderedView borderColor="${this.classroot.style.bordercolumnlistcolor}" borderSize="1" height="${this.parent.height}" name="borderedView" width="${this.parent.width}">
			<variable name="hScrollHeight" type="number" value="${(this.hScroll.visible ? this.hScroll.height : 0)}"/>
			<variable name="vScrollWidth" type="number" value="${(this.vScroll.visible ? this.vScroll.width : 0)}"/>

			<Component clip="true" height="${this.parent.height - this.parent.hScrollHeight - 6}" name="clippedContent" width="${this.parent.width - this.parent.vScrollWidth - 6}" x="3" y="3">
				<Component name="content">
					<AxisLayout axis="y"/>
				</Component>
			</Component>
			<HorizontalScrollbar name="hScroll" scrolltarget="${this.parent.clippedContent.content}" visible="${this.scrollable}" width="${this.parent.width - this.parent.vScrollWidth}" x="${-1}" y="${this.parent.clippedContent.y + this.parent.clippedContent.height + 2}"/>
			<VerticalScrollbar height="${this.parent.height - this.parent.hScrollHeight}" name="vScroll" scrolltarget="${this.parent.clippedContent.content}" visible="${this.scrollable}" x="${this.parent.clippedContent.x + this.parent.clippedContent.width + 2}" y="${-1}"/>
			<Component bgcolor="#E0EAEF" height="${this.parent.hScrollHeight - 1}" name="vScrollBottom" visible="${this.parent.vScroll.visible &amp;&amp; this.parent.hScroll.visible}" width="${this.parent.vScrollWidth - 1}" x="${this.parent.vScroll.x}" y="${this.parent.vScroll.y + this.parent.vScroll.height}"/>
		</BorderedView>
	</FocusableComponent>
	
	<!---
		@keywords private
		
		cmc/foundation/ObjectTextItem is for internal use by {@link cmc/foundation/MultipleDeleteConfirmationDialog} 
		to bind a {@link cmc/foundation/ModelObject} with this item. 
		Both the icon and the display name of the object will be displayed beside the item.
	-->
	<Component classDefinition="true" definitionName="cmc/foundation/ObjectTextItem">
		<dependency localName="EventUtil" moduleName="cmc/foundation/EventUtil"/>
		<dependency localName="Logger" moduleName="cmc/shell/Logger"/>
		<!---
			A reference to the instance of the {@link cmc/foundation/ModelObject} whose icon is being displayed. 
		-->
		<variable name="o" value="${null}"/>
		<!---
			Object icon.
		-->
		<variable name="icon" type="string" value="treeFolderResource"/>
		<!---
			Object display name.
		-->
		<variable name="objectDisplayName" value="${null}"/>
		<!---
			Indicates that this object has an error.
		-->
		<variable name="hasError" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Set the {@link cmc/foundation/ModelObject} to be associated with this check box. 
			@param cmc/foundation/ModelObject newObject New object associated with this check box.
		-->
		<method args="newObject" name="setModelObject">
			<![CDATA[
			if (this.o != newObject) {
				this.o = newObject;
				if (this.o == null) {
					this.setVariable("icon", null);
					this.setVariable("objectDisplayName", "");
					this.setVariable("hasError", false);
				}
				else {
					if (this.o.getIcon() != null) {
						this.setVariable("icon", this.o.getIcon());
					}
					if (this.o.objectDisplayName != null) {
						this.setVariable("objectDisplayName", this.o.objectDisplayName);
						if (Logger.Singleton.enabled) {
							Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.view", "FINER", "cmc/foundation/ObjectTextItem", "setModelObject(newObject)", "objectDisplayName: " + this.objectDisplayName);
						}
					}
					var newHasError = this.o.openGroupObject != null && this.o.openGroupObject.errorInOpenGroup;
					if (newHasError != this.hasError) {
						this.setVariable("hasError", newHasError);
					}
				}
				EventUtil.trigger(this, "ono", this.o);
			}
			]]>
		</method>
		
		<Component name="objectItem">
			<Component imageSet="${this.classroot.icon}" name="_icon"/>
			<Component imageSet="treeErrorResource" name="_errorIcon" visible="${this.classroot.hasError}" x="${this.parent._icon.x + this.parent._icon.width - this.width - 1}" y="${this.parent._icon.y + this.parent._icon.height - this.height}"/>
			<TextComponent name="_displayName" resize="true" text="${this.escapeText(this.classroot.objectDisplayName)}" x="${this.parent._errorIcon.x + this.parent._errorIcon.width + 1}"/>
		</Component>
		
		<!--- @keywords private -->
		<method args="o" name="set_o">
			<![CDATA[
			this.setModelObject(o);
			]]>
		</method>
	</Component>

	<!---
		@keywords private
		The delete collection reference object confirmation dialog. This dialog is used to prompt the user
		whether to delete the primary object or just remove the reference object.
	-->
	<Dialog definitionName="cmc/foundation/CollectionReferenceObjectDeleteConfirmationDialog" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The object that is to be deleted.
		-->
		<variable name="deleteObject" value="${null}"/>
		
		<!-- 
			Business Object Editor of the object to be deleted
		 -->
		<variable name="oEditor" value="${null}"/>

		<!---
			Confirm that the specified object should be deleted, or only have the reference removed.
			@param cmc/foundation/ModelObject o: the object to be deleted or its reference removed
		-->
		<method args="o" name="openCollectionReferenceObjectDeleteConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.contentArea.prompt.setVariable("text", foundationResources.Singleton.replaceValues("deleteCollectionReferenceObjectDialogPrompt", [o.getReferencedObject().objectDisplayName]));
			this.contentArea.deletePrompt.setVariable("text", foundationResources.Singleton.replaceValues("deleteCollectionReferenceObjectDialogDeletePrompt", [o.getReferencedObject().objectDisplayName]));
			this.contentArea.removePrompt.setVariable("text", foundationResources.Singleton.replaceValues("deleteCollectionReferenceObjectDialogRemovePrompt", [o.getReferencedObject().objectDisplayName, o.parentObject.objectDisplayName]));
			this.deleteObject = o;
			this.oEditor = o.model.oEditor;
			]]>
		</method>

		<!---
			Close this delete confirmation dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.deleteObject = null;
			this.oEditor = null;
			]]>
		</method>

		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>

		<!---
			Remove the reference object.
		-->
		<method name="handleRemoveObject">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/CollectionReferenceObjectDeleteConfirmationDialog handleRemoveObject");
			this.deleteObject.deleteObject(false, true);
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>

		<!---
			Delete the object.
		-->
		<method name="handleDeleteObject">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/CollectionReferenceObjectDeleteConfirmationDialog handleDeleteObject");
			this.deleteObject.getReferencedObject().deleteObject();
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>

		<AxisLayout axis="x" spacing="15"/>
		<Component imageSet="dialogWarningIcon" name="infoIcon"/>
		<Component name="contentArea">
			<TextComponent multiline="true" name="prompt" width="300"/>
			<TextComponent multiline="true" name="deletePrompt" width="300"/>
			<TextComponent multiline="true" name="removePrompt" width="300"/>
			<AxisLayout axis="y" spacing="3"/>
		</Component>
		<Button name="deleteCancelBtn" placement="leftFooter" text="${foundationResources.Singleton.deleteCollectionReferenceObjectsDialogCancel.string}" primary="false">
			<handler name="onclick">
				<![CDATA[
				this.parent.closeWindow();
				]]>
			</handler>
		</Button>
		<Component name="footerView" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button isdefault="true" name="deleteDeleteBtn" text="${foundationResources.Singleton.deleteCollectionReferenceObjectsDialogDelete.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleDeleteObject();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button name="deleteRemoveBtn" text="${foundationResources.Singleton.deleteCollectionReferenceObjectsDialogRemove.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleRemoveObject();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>
	</Dialog>

	<!---
		@keywords private
		The delete multiple collection reference objects confirmation dialog. This dialog is used to prompt
		the user whether to delete the primary objects or just remove the reference objects.
	-->
	<Dialog definitionName="cmc/foundation/MultipleCollectionReferenceObjectDeleteConfirmationDialog" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The array of objects that are to be deleted.
		-->
		<variable name="deleteObjects" value="${null}"/>
		
		<!-- 
			Business Object Editor of the objects to be deleted
		 -->
		<variable name="oEditor" value="${null}"/>

		<!---
			Confirm that the specified objects should be deleted, or only have the reference removed.
			@param array objects: the objects to be deleted or their reference removed
		-->
		<method args="objects" name="openMultipleCollectionReferenceObjectDeleteConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.contentArea.removePrompt.setVariable("text", foundationResources.Singleton.replaceValues("deleteCollectionReferenceObjectsDialogRemovePrompt", [objects[0].parentObject.objectDisplayName]));
			this.deleteObjects = objects;
			this.oEditor = objects[0].model.oEditor;
			this.objectsArea.objectItems.setObjects(this.deleteObjects);
			]]>
		</method>

		<!---
			Set the focus to Remove button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.deleteRemoveBtn);
			]]>
		</method>

		<!---
			Close multiple discard confirmation dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.objectsArea.objectItems.setObjects([]);
			this.inherited(arguments);
			this.deleteObjects = null;
			this.oEditor = null;
			]]>
		</method>

		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>

		<!---
			Remove the reference objects.
		-->
		<method name="handleRemoveObjects">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/MultipleCollectionReferenceObjectDeleteConfirmationDialog handleRemoveObjects");
			for (var i = 0; i < this.deleteObjects.length; i++) {
				this.deleteObjects[i].deleteObject(false, true);
			}
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>

		<!---
			Delete the objects.
		-->
		<method name="handleDeleteObjects">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/MultipleCollectionReferenceObjectDeleteConfirmationDialog handleDeleteObjects");
			for (var i = 0; i < this.deleteObjects.length; i++) {
				this.deleteObjects[i].getReferencedObject().deleteObject();
			}
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>

		<AxisLayout axis="x" spacing="15"/>
		<Component imageSet="dialogWarningIcon" name="infoIcon"/>
		<Component name="contentArea">
			<TextComponent multiline="true" name="prompt" text="${foundationResources.Singleton.deleteCollectionReferenceObjectsDialogPrompt.string}" width="300"/>
			<TextComponent multiline="true" name="deletePrompt" text="${foundationResources.Singleton.deleteCollectionReferenceObjectsDialogDeletePrompt.string}" width="300"/>
			<TextComponent multiline="true" name="removePrompt" width="300"/>
			<AxisLayout axis="y" spacing="3"/>
		</Component>
		<Component clip="true" ignoreLayout="true" name="objectsArea" x="${this.parent.contentArea.x}" y="${this.parent.contentArea.y + this.parent.contentArea.height + 5}">
			<ObjectItemList height="150" name="objectItems" width="${this.parent.parent.contentArea.width}"/>
		</Component>
		<Button name="deleteCancelBtn" placement="leftFooter" text="${foundationResources.Singleton.deleteCollectionReferenceObjectsDialogCancel.string}" primary="false">
			<handler name="onclick">
				<![CDATA[
				this.parent.closeWindow();
				]]>
			</handler>
		</Button>
		<Component name="viewButtons" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button isdefault="true" name="deleteDeleteBtn" text="${foundationResources.Singleton.deleteCollectionReferenceObjectsDialogDelete.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleDeleteObjects();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button name="deleteRemoveBtn" text="${foundationResources.Singleton.deleteCollectionReferenceObjectsDialogRemove.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleRemoveObjects();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>
	</Dialog>
	
	<!--- 
		The Edit Column Dialog. This dialog is used to prompt the user to select column of an active grid {@link cmc/foundation/ObjectGrid}
		and edit the values of the cells being selected under the column.
	 -->
	<Dialog definitionName="cmc/foundation/EditColumnDialog" singletonDefinition="true" title="${foundationResources.Singleton.editColumnDialogTitle.string}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="RootComponent" moduleName="cmc/RootComponent"/>
	    
	    <!---
			@keywords private
			The active {link@ cmc/foundation/ObjectGrid}
		-->
		<variable name="objectGrid"/>
		
		<!--- 
			@keywords private 
			Open Edit Column Dialog
		-->
		<method args="objGrid" name="openEditColumnDialog">
			<![CDATA[
			this.openWindow();
			this.objectGrid = objGrid;
			var firstColumn = null;
			for (var i = 0; i < objGrid.columns.length; i++) {
				var column = objGrid.columns[i];
				if (column.visible && column.editable && column.columnEditorClass != null) {
					this.editColumnArea.columnCombo.addItem(column.displayText, column);
					if (firstColumn == null) firstColumn = column;
				}
			}
			this.editColumnArea.columnCombo.selectItem(firstColumn);
			]]>
		</method>
		
		<!--- 
			@keywords private 
			Edit the values of the cells being selected under the column.
		-->
		<method name="doEditColumn">
			<![CDATA[
			var selectedColumn = this.editColumnArea.columnCombo.getValue();
			var newValue = this.editColumnArea.newValueSection.inputArea.editor.getValue();
			var selectedObjects = this.objectGrid.getSelectedObjects();
			if (selectedObjects && selectedObjects.length > 0) {
				for (var i = 0; i < selectedObjects.length; i++) {
					if (selectedColumn.isEditable(selectedObjects[i])) {
						var o = selectedColumn.getObject(selectedObjects[i], null);
						var propertyName = selectedColumn.getPropertyName(selectedObjects[i]);
						var property = o.getProperty(propertyName);
						property.change(newValue);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Close Edit Column dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.objectGrid = null;
			this.editColumnArea.columnCombo.setValues(null);
			]]>
		</method>
		
		<!--- 
			@keywords private 
			After tried to create editor, if error message is generated,
			the editor was not created successfully and so display the error message
			to user.
		-->
		<method args="errMsg" name="checkErrorMessage">
			<![CDATA[
			if (errMsg) {
				this.footerView.editColumnOkBtn.setVariable("enabled", false);
				this.footerView.editColumnApplyBtn.setVariable("enabled", false);
				this.editColumnArea.newValueSection.errorMessageText.setVariable("visible", true);
				this.editColumnArea.newValueSection.errorMessageText.setVariable("text", errMsg);
			}
			else {
				this.footerView.editColumnOkBtn.setVariable("enabled", true);
				this.footerView.editColumnApplyBtn.setVariable("enabled", true);
				this.editColumnArea.newValueSection.errorMessageText.setVariable("visible", false);
				this.editColumnArea.newValueSection.errorMessageText.setVariable("text", errMsg);
			}
			]]>
		</method>
		
		<Component focusable="false" name="editColumnArea">
			<AxisLayout axis="y"/>
			<TextComponent name="columnSelectionText" text="${foundationResources.Singleton.columnSelectionTitle.string}"/>
			
			<!-- The combobox populated with editable columns -->
			<BaseComboBox name="columnCombo" width="${this.parent.newValueSection.width > 420 ? this.parent.newValueSection.width : 420}">
				<handler name="onselectedValue">
					<![CDATA[
					this.parent.newValueSection.inputArea.setSelectedColumn(this.getValue());
					]]>
				</handler>
			</BaseComboBox>
			<Component height="20"/>
			<Component name="newValueSection">
				<AxisLayout axis="x" spacing="10"/>
				<Component name="promptArea">
					<AxisLayout/>
					<TextComponent name="setColumnText" text="${foundationResources.Singleton.setColumnPrompt.string}"/>
					<TextComponent name="columnText" text=""/>
				</Component>
				
				<Component name="inputArea" visible="${!this.parent.errorMessageText.visible}">
					<variable name="availableWidth" type="number" value="${420 - this.parent.promptArea.width - 10}"/>
					<variable name="editor" value="${null}"/>
					
					<!-- Cache one editor instance for each type of editColumnClass {string, editor} -->
					<variable name="columnEditorMap" value="${{}}"/>
					
					<!--- @keywords private -->
					<method args="col" name="setSelectedColumn">
						<![CDATA[
						this.parent.promptArea.columnText.setVariable("text", col != null ? col.displayText : "");
						if (this.editor != null) {
							this.editor.setVariable("column", null);
							this.editor.setVariable("selectedObjects", null);
							this.editor.setVariable("visible", false);
							this.editor = null;
						}
						var errorMessage = foundationResources.Singleton.columnEditorDisabledCellsMsg.string;
						if (col != null) {
							var selectedObjects = col.parent.getSelectedObjects();
							if (selectedObjects.length > 0 && col.isEditable(selectedObjects[0])) {
								var o = col.getObject(selectedObjects[0]);
								if (o != null) {
									var showEditor = true;
									var firstPropertyName = col.getPropertyName(selectedObjects[0]);
									var firstPropertyDefinition = o.objectDefinition.getPropertyDefinition(o, firstPropertyName);
									var firstValue = o.getPropertyValue(firstPropertyName);
									for (var i = 1; i < selectedObjects.length; i++) {
										if (!col.isEditable(selectedObjects[i])) {
											showEditor = false;
											break;
										}
										else {
											o = col.getObject(selectedObjects[i]);
											if (o == null) {
												showEditor = false;
												break;
											}
											else {
												var propertyName = col.getPropertyName(selectedObjects[i]);
												var propertyDefinition = o.objectDefinition.getPropertyDefinition(o, propertyName);
												if (firstPropertyName != propertyName || firstPropertyDefinition != propertyDefinition) {
													showEditor = false;
													errorMessage = foundationResources.Singleton.columnEditorDifferentTypeErrorMsg.string;
													break;
												}
											}
										}
									}
									if (showEditor) {
										var colEditorClassName = col.getColumnEditorClass(selectedObjects);
										if (colEditorClassName) {
											this.editor = this.columnEditorMap[colEditorClassName];
											if (this.editor) {
												this.editor.setVariable("column", this);
												this.editor.setVariable("selectedObjects", selectedObjects);
												this.editor.setVariable("visible", true);
											}
											else {
												this.editor = new colEditorClassName.Class(this, {
													column: col,
													selectedObjects: selectedObjects
												});
											}
											this.editor.resetValue(firstValue);
											errorMessage = null;
										}
										else {
											errorMessage = foundationResources.Singleton.columnEditorDifferentTypeErrorMsg.string;
										}
									}
								}
							}
						}
						this.parent.parent.parent.checkErrorMessage(errorMessage);
						]]>
					</method>
				</Component>
				<TextComponent multiline="true" name="errorMessageText" text="" visible="false" width="${420 - this.parent.promptArea.width - 10}"/>
			</Component>
		</Component>
	
		<Button name="editColumnCalcelBtn" placement="leftFooter" text="${foundationResources.Singleton.editColumnDialogCancel.string}" primary="false">
			<handler name="onclick">
				<![CDATA[
				this.parent.closeWindow();
				]]>
			</handler>
		</Button>
		<Component name="footerView" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="editColumnApplyBtn" text="${foundationResources.Singleton.editColumnDialogApply.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.doEditColumn();
					]]>
				</handler>
			</Button>
			<Button name="editColumnOkBtn" text="${foundationResources.Singleton.editColumnDialogOk.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.doEditColumn();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>
		
	</Dialog>

	<!---
		Dialog used by object properties to ask the user whether or not to launch the Information Center
		for an introduction to the properties view. 
		@keywords private
	-->
	<Dialog definitionName="cmc/foundation/IntroPrompt" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="PreferenceManager" moduleName="cmc/shell/PreferenceManager"/>
		<!--- Text to ask the user whether or not to launch the Information Center. -->
		<variable name="promptText" type="string" value=""/>
		<!---
			The name of the preference key that the Preference Manager should check before launching the introduction dialog.
			If the user selects the "Don't ask me this again" checkbox, a value of "true" will be stored to this preference key.
		-->
		<variable name="preferenceKey" type="string" value=""/>
		<!--- Relative URL in the Information Center to launch if the user selects "Yes" to the dialog. -->
		<variable name="url" type="string" value=""/>

		<!---
			Sets the provided properties and opens the dialog window.
			@param string promptText Text to ask the user whether or not to launch the Information Center
			@param string url URL to launch
			@param string preferenceKey Name of the preference key that the Preference Manager should check before launching the introduction dialog
		-->
		<method args="promptText, url, preferenceKey" name="openIntroPrompt">
			<![CDATA[
			this.setVariable("promptText", promptText);
			this.setVariable("url", url);
			this.setVariable("preferenceKey", preferenceKey);
			this.openWindow();
			this.rightColumn.dontAsk.setValue(false);
			]]>
		</method>

		<AxisLayout axis="x" spacing="15"/>
		<Component imageSet="showMeDialogIcon" name="infoIcon"/>
		<Component name="rightColumn">
			<AxisLayout axis="y" spacing="20"/>
			<TextComponent multiline="true" name="text" text="${this.parent.parent.promptText}" width="300" lineHeight="16"/>
			<BaseCheckbox name="dontAsk" text="${foundationResources.Singleton.dontAskAgain.string}">
				<method args="s" name="_applystyle">
					<![CDATA[
					this._title.setVariable('fgcolor', '0x000000');
					]]>
				</method>
			</BaseCheckbox>
		</Component>

		<Button name="cancelBtn" placement="leftFooter" text="${foundationResources.Singleton.simpleDialogCancel.string}" primary="false">
			<handler name="onclick">
				<![CDATA[
				this.parent.closeWindow();
				]]>
			</handler>
		</Button>
		<Component name="viewButtons" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="noBtn" text="${foundationResources.Singleton.simpleDialogNo.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleNo();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button isdefault="true" name="yesBtn" text="${foundationResources.Singleton.simpleDialogYes.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleYes();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>

		<!---
			Set the focus to Yes button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>

		<!---
			This method is called when the user clicks on the Yes button to launch the help URL link. If
			the user selected the "Don't ask me this again" check box, the preference is saved.
		-->
		<method name="handleYes">
			<![CDATA[
			if (this.preferenceKey && this.preferenceKey != "" && this.rightColumn.dontAsk.value) {
				PreferenceManager.Singleton.setPreference(this.preferenceKey, "true");
			}
			if (this.url && this.url != "") {
				var caller = this;
				require(["cmc/shell/HelpManager"], function(HelpManager) {
					HelpManager.Singleton.openHelpLink(caller.url);
				});
			}
			]]>
		</method>
		
		<!---
			This method is called when the user clicks on the No button. If the user
			selected the "Don't ask me this again" check box, the preference is saved.
		-->
		<method name="handleNo">
			<![CDATA[
			if (this.preferenceKey && this.preferenceKey != "" && this.rightColumn.dontAsk.value) {
				PreferenceManager.Singleton.setPreference(this.preferenceKey, "true");
			}
			]]>
		</method>
	</Dialog>

	<!---
		@keywords private
		The collection reference object remove confirmation dialog.
		This dialog is used to prompt the user to confirm before removing a collection reference object.
	-->
	<AlertDialog definitionName="cmc/foundation/CollectionReferenceObjectRemoveConfirmationDialog" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The object that is to be removed.
		-->
		<variable name="removeObject" value="${null}"/>

		<!---
			Business Object Editor of the object to be removed.
		-->
		<variable name="oEditor" value="${null}"/>

		<!---
			Confirm that the specified object can be removed.
			@param cmc/foundation/ModelObject o: The object to be removed.
		-->
		<method args="o" name="openCollectionReferenceObjectRemoveConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("collectionReferenceObjectRemoveConfirmationDialogText", [o.getReferencedObject().objectDisplayName, o.parentObject.objectDisplayName]));
			this.removeObject = o;
			this.oEditor = o.model.oEditor;
			]]>
		</method>

		<!---
			Set the focus to Yes button.
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>

		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>

		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.removeObject = null;
			this.oEditor = null;
			]]>
		</method>

		<!---
			Remove the object.
		-->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) {
				EventTimer.Singleton.start("cmc/foundation/CollectionReferenceObjectRemoveConfirmationDialog handleYes");
			}
			this.removeObject.deleteObject(false, true);
			if (EventTimer.Singleton.enabled) {
				EventTimer.Singleton.end();
			}
			]]>
		</method>
	</AlertDialog>

	<!---
		@keywords private
		The multiple collection reference objects remove confirmation dialog.
		This dialog is used to prompt the user to confirm before removing multiple collection reference objects.
	-->
	<ListAlert definitionName="cmc/foundation/MultipleCollectionReferenceObjectRemoveConfirmationDialog" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The array of objects that are to be removed.
		-->
		<variable name="removeObjects" value="${null}"/>

		<!---
			Business Object Editor of the objects to be removed.
		-->
		<variable name="oEditor" value="${null}"/>

		<!---
			Confirm that the specified objects can be removed.
			@param array objects: The objects to be removed.
		-->
		<method args="objects" name="openMultipleCollectionReferenceObjectRemoveConfirmationDialog">
			<![CDATA[
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("multipleCollectionReferenceObjectRemoveConfirmationDialogText", [objects[0].parentObject.objectDisplayName]));
			this.removeObjects = objects;
			this.oEditor = objects[0].model.oEditor;
			this.openListAlertDialog(this.removeObjects);
			]]>
		</method>

		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>

		<!---
			Close multiple collection reference objects remove confirmation dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.removeObjects = null;
			this.oEditor = null;
			]]>
		</method>

		<!---
			Remove the objects.
		-->
		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) {
				EventTimer.Singleton.start("cmc/foundation/MultipleCollectionReferenceObjectRemoveConfirmationDialog handleYes");
			}
			for (var i = 0; i < this.removeObjects.length; i++) {
				this.removeObjects[i].deleteObject(false, true);
			}
			if (EventTimer.Singleton.enabled) {
				EventTimer.Singleton.end();
			}
			]]>
		</method>
	</ListAlert>

	<!---
		@keywords private
		This confirmation dialog is used when the user wants to restore a new content version for a business object.
	-->
	<AlertDialog definitionName="cmc/foundation/RestoreContentVersionConfirmationDialog" showCancel="false" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="RestoreContentVersionService" moduleName="cmc/foundation/RestoreContentVersionService"/>
		
		<!-- 
			Business Object Editor
		 -->
		<variable name="oEditor" value="${null}"/>
		
		<!-- 
			The content version object to be restored
		 -->		
		<variable name="restoreObject" value="${null}"/>
		
		<!---
			Open and initialize the restore content version dialog
			@param cmc/foundation/ModelObject o: the content version object to be restored
		-->
		<method args="o" name="openRestoreContentVersionConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.restoreObject = o;
			this.setVariable("promptText", foundationResources.Singleton.replaceValues("restoreContentVersionConfirmation", [this.restoreObject.getPropertyValue("versionNumber")]));
			this.oEditor = this.restoreObject.model.oEditor;
			]]>
		</method>
		
		<!---
			Set the focus to Yes button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.oEditor = null;
			this.restoreObject = null;
			]]>
		</method>
		
	    <!---
	    	Restore the object
	    -->
		<method name="handleYes">
			<![CDATA[
			RestoreContentVersionService.Singleton.doRequest(this.restoreObject, {
				versionId: this.restoreObject.getPropertyValue("versionId")
			});
			]]>
		</method>
	</AlertDialog>

	<!---
		@keywords private
		This dialog is used when the user wants to create a new content version for a business object.
	-->
	<Dialog definitionName="cmc/foundation/CreateContentVersionDialog" minHeight="300" minWidth="442" singletonDefinition="true" title="${foundationResources.Singleton.ContentVersionCreateDialogTitle.string}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="CreateContentVersionService" moduleName="cmc/foundation/CreateContentVersionService"/>
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<dependency localName="ContextUtil" moduleName="cmc/foundation/ContextUtil"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="LangUtil" moduleName="cmc/foundation/LangUtil"/>

		<!--- The objects that will be versioned -->
		<variable name="objects" value="${null}"/>
				
		<!---
			@keywords private
			Open and initialize the create content version dialog
		-->
		<method args="objects" name="openCreateContentVersionDialog">
			<![CDATA[
			this.objects = objects;
			this.openWindow();
			if (this.objects.length == 1) {
				this.createContentVersionArea.descriptionVersionMessageView.descriptionMessage.setVariable("text", foundationResources.Singleton.replaceValues("ContentVersionCreateDialogDescriptionMessage", [this.objects[0].objectDisplayName]));
			}
			else {
				this.createContentVersionArea.descriptionVersionMessageView.descriptionMessage.setVariable("text", foundationResources.Singleton.replaceValues("ContentVersionCreateDialogMultipleVersionsDescriptionMessage", [this.objects.length]));
			}
			this.createContentVersionArea.nameArea.versionName.setText("");
			this.createContentVersionArea.commentArea.versionComments.setText("");
			this.objectsValidation();
			]]>
		</method>
	    	
		<!---
			@keywords private
			Set the focus to versionName input box
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.createContentVersionArea.nameArea.versionName);
			]]>
		</method>

		<!---
			@keywords private
			This method is called when the user selects the OK option.
		-->
		<method name="handleCreate">
			<![CDATA[
			var versionName = this.createContentVersionArea.nameArea.versionName.getText();
			var comment = this.createContentVersionArea.commentArea.versionComments.getText();
			for (var i = 0; i < this.objects.length; i++) {
				var o = this.objects[i];
				CreateContentVersionService.Singleton.doRequest(o, {
					versionName: versionName,
					comment: comment,
					objectType: o.objectType,
					objectId: o.objectId
				});
			}
			]]>
		</method>

		<!---
			@keywords private
			Validate the objects and test if any of them are Inherited objects, display warning if Inherited objects were selected.
		-->
		<method name="objectsValidation">
			<![CDATA[
			this.createContentVersionArea.createVersionWarningMessageView.setVariable("visible", false);
			for (var i = 0; i < this.objects.length; i++) {
				var o = this.objects[i];
				var storeConfig = ContextUtil.Singleton.findStoreConfig(o);
				if ((storeConfig != null) && (o.objectStoreId != storeConfig.storeId)) {
					this.createContentVersionArea.createVersionWarningMessageView.warningMessage.setVariable("text", foundationResources.Singleton.ContentVersionCreateDialogInheritedObjectWarning.string);
					this.createContentVersionArea.createVersionWarningMessageView.setVariable("visible", true);
					break;
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Validate the input of the name and comment fields
		-->
		<method name="inputValidation">
			<![CDATA[
			var versionName = this.createContentVersionArea.nameArea.versionName.getText();
			var comment = this.createContentVersionArea.commentArea.versionComments.getText();
			var errorMessage = "";
			if (LangUtil.Singleton.getUTF8ByteCount(versionName) > 254) {
				errorMessage = foundationResources.Singleton.replaceValues("propertySizeTooLarge", [foundationResources.Singleton.ContentVersionCreateDialogName.string]);
				this.createContentVersionArea.createVersionErrorMessageView.errorMessage.setVariable("text", errorMessage);
				this.createContentVersionArea.createVersionErrorMessageView.setVariable("visible", true);
				this.footerView.createBtn.setVariable("enabled", false);
			}
			else if (LangUtil.Singleton.getUTF8ByteCount(comment) > 4000) {
				errorMessage = foundationResources.Singleton.replaceValues("propertySizeTooLarge", [foundationResources.Singleton.ContentVersionCreateDialogComment.string]);
				this.createContentVersionArea.createVersionErrorMessageView.errorMessage.setVariable("text", errorMessage);
				this.createContentVersionArea.createVersionErrorMessageView.setVariable("visible", true);
				this.footerView.createBtn.setVariable("enabled", false);
			}
			else {
				this.footerView.createBtn.setVariable("enabled", !StringUtil.Singleton.isBlankString(versionName));
				this.createContentVersionArea.createVersionErrorMessageView.setVariable("visible", false);
			}
			]]>
		</method>
				
		<Component focusable="false" name="createContentVersionArea">
			<Component name="descriptionVersionMessageView">
				<TextComponent multiline="true" name="descriptionMessage" text="${foundationResources.Singleton.ContentVersionCreateDialogDescriptionMessage.string}" width="355"/>
				<AxisLayout axis="y" spacing="2"/>
			</Component>
			<Component name="createVersionWarningMessageView" visible="false">
				<TextComponent multiline="true" name="warningMessage" width="335"/>
			</Component>
			<Component name="createVersionErrorMessageView" visible="false">
				<Component imageSet="errorIcon" y="2"/>
				<TextComponent multiline="true" name="errorMessage" width="335"/>
				<AxisLayout axis="x" spacing="4"/>
			</Component>
			<Component name="nameArea">
				<TextComponent text="${foundationResources.Singleton.ContentVersionCreateDialogName.string}"/>
				<InputText name="versionName" width="355">
					<handler name="ontext">
						<![CDATA[
						this.parent.parent.parent.inputValidation();
						]]>
					</handler>
				</InputText>
				<AxisLayout axis="y" spacing="2"/>
			</Component>

			<Component name="commentArea">
				<TextComponent text="${foundationResources.Singleton.ContentVersionCreateDialogComment.string}"/>
				<InputText height="100" maximumHeight="100" multiline="true" name="versionComments" width="355">
					<handler name="ontext">
						<![CDATA[
						this.parent.parent.parent.inputValidation();
						]]>
					</handler>
				</InputText>
				<AxisLayout axis="y" spacing="2"/>
			</Component>

			<AxisLayout axis="y" spacing="10"/>
		</Component>
	
		<Component name="footerView" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="cancelBtn" text="${foundationResources.Singleton.simpleDialogCancel.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button isdefault="true" name="createBtn" text="${foundationResources.Singleton.ContentVersionCreateDialogButton.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleCreate();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>
	</Dialog>

	<!---
		This dialog is used to prompt a user to confirm the user will delete all Preconfigured Components.
	-->
	<AlertDialog definitionName="cmc/foundation/DeletePreconfigConfirmationDialog" showNo="true" showOK="false" showYes="true" singletonDefinition="true">
		<dependency localName="catalogResources" moduleName="cmc/catalog/CatalogResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The object that is to be deleted.
		-->
		<variable name="deleteObject" value="${null}"/>
		
		<!-- 
			Business Object Editor of the object to be deleted
		 -->
		<variable name="oEditor" value="${null}"/>
	
		<!---
			Confirm that the specified object can be deleted
			@param cmc/foundation/ModelObject o: the object to be deleted
		-->
		<method args="o" name="openDeletePreconfigConfirmationDialog">
			<![CDATA[
			this.openWindow();
			this.setVariable("promptText", catalogResources.Singleton.kitDeletePreconfigConfirm.string);
			this.deleteObject = o;
			this.oEditor = o.model.oEditor;
			]]>
		</method>
		
		<!---
			Set the focus to Yes button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.viewButtons.yesBtn);
			]]>
		</method>
		
		<!---
			Restore focus after close.
		-->
		<method name="restoreFocus">
			<![CDATA[
			this.inherited(arguments);
			if (FocusUtil.getFocus() == null) {
				this.oEditor.restoreFocus();
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.deleteObject = null;
			this.oEditor = null;
			]]>
		</method>	

		<method name="handleYes">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/DeletePreconfigConfirmationDialog handleYes");
			var caller = this;
			require(["cmc/foundation/DeletePreconfigService"], function(DeletePreconfigService) {
				DeletePreconfigService.Singleton.doRequest(caller.deleteObject);
			});
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
	</AlertDialog>

	<!---
		@keywords private
		This service is used to delete all Preconfigured Components for the specified dynamic kit.
	-->
	<Service definitionName="cmc/foundation/DeletePreconfigService" singletonDefinition="true" transactionService="true" url="/cmc/UpdateCatalogEntryExtraProperties">
		<dependency localName="ServiceTransactionUtil" moduleName="cmc/foundation/ServiceTransactionUtil"/>
		<dependency localName="catalogResources" moduleName="cmc/catalog/CatalogResources"/>
		<dependency localName="ModelUtil" moduleName="cmc/foundation/ModelUtil"/>
		<ServiceParam name="storeId"/>
		<ServiceParam name="catentryId" propertyName="catentryId"/> 
		<ServiceParam name="xprop_dynamicKitDefaultConfiguration" optional="true" value=""/>  
	
		<!---
			@keywords private
			This method is called when this custom service completed successfully. Client objects will be released if
			necessary to make sure the Preconfiguration is up to date to reflect the changes after the
			delete action.

			@param cmc/foundation/ModelObject requestParent: The object on which this custom service was performed.
		-->
		<method args="requestParent" name="handleServiceSuccess">
			<![CDATA[
			var deleteObjects = [];
			for (var key in requestParent.childObjectMap) {
				var o = requestParent.childObjectMap[key];
				if (!o.getIsVersionObject() && (o.objectType == "SterlingDynamicKitComponent" || o.objectType == "InheritedSterlingDynamicKitComponent")) {
					deleteObjects.push(o);
				}
			}
			while (deleteObjects.length > 0) {
				var o = deleteObjects.shift();
				ModelUtil.Singleton.releaseModelObject(o);
			}
			this.inherited(arguments);
			var msg = catalogResources.Singleton.kitDeletePreconfigSuccessful.string;
			var messageType = "deletePreconfigSuccessful";
			ServiceTransactionUtil.Singleton.setTransactionEventMessage(requestParent.transaction, messageType, msg);
			]]>
		</method>
	</Service>

	<!---
		@keywords private
		Select store dialog. Use this dialog to present the user with a list of stores.
	-->
	<Dialog definitionName="cmc/foundation/SelectStoreDialog" minHeight="200" minWidth="325" singletonDefinition="true" title="${foundationResources.Singleton.selectStoreDialogTitle.string}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The store selection handler. This object must have a changeStore method.
		-->
		<variable name="storeSelectionHandler"/>

		<!---
			@keywords private
			Open and initialize the select store dialog.
		-->
		<method args="storeSelectionHandler, stores" name="openSelectStoreDialog">
			<![CDATA[
			this.openWindow();
			this.storeSelectionHandler = storeSelectionHandler;
			this.selectStoreContentArea.storeCombo.setValues(stores);
			if (stores.length > 0) {
				this.selectStoreContentArea.storeCombo.setVariable("selectedValue", stores[0]);
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			this.inherited(arguments);
			this.storeSelectionHandler = null;
			this.selectStoreContentArea.storeCombo.setValues(null);
			]]>
		</method>
		
		<!---
			Trigger change store.
		-->
		<method name="handleOK">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/ChangeStoreConfirmationDialog handleOK");
			this.storeSelectionHandler.changeStore(this.selectStoreContentArea.storeCombo.selectedValue, true);
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
		
 		<!---
			Cancel the change store action.
		-->
		<method name="handleCancel">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/ChangeStoreConfirmationDialog handleCancel");
			if (this.storeSelectionHandler.cancelChangeStore) {
				this.storeSelectionHandler.cancelChangeStore();
			}
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
		
		<Component name="selectStoreContentArea">
			<AxisLayout axis="y" spacing="10"/>
			<TextComponent multiline="true" name="text" text="${foundationResources.Singleton.selectStoreDialogPrompt.string}" width="300"/>
			<!-- The combobox populated with editable columns -->
			<BaseComboBox name="storeCombo"/>
		</Component>

		<Component name="footerView" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="cancelBtn" text="${foundationResources.Singleton.simpleDialogCancel.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleCancel();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button name="okBtn" text="${foundationResources.Singleton.simpleDialogOK.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleOK();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>
	</Dialog>
	
	<!---
		@keywords private
		Select workspace task dialog. Use this dialog to present the user with a list of workspace tasks.
	-->
	<Dialog definitionName="cmc/foundation/SelectTaskDialog" minHeight="200" minWidth="350" singletonDefinition="true" title="${foundationResources.Singleton.selectTaskDialogTitle.string}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<!---
			The workspace task selection handler. This object must have a changeTask method.
		-->
		<variable name="taskSelectionHandler"/>
		<!--- 
			This attribute indicates whether the cancel change task method should be invoked or not.
		-->
		<variable name="isCancelAction" type="boolean" value="true"/>
		<!---
			@keywords private
			Open and initialize the select store dialog.
		-->
		<method args="taskSelectionHandler, tasks" name="openSelectTaskDialog">
			<![CDATA[
			this.openWindow();
			this.taskSelectionHandler = taskSelectionHandler;
			this.selectTaskContentArea.taskCombo.setValues(tasks);
			if (tasks.length > 0) {
				this.selectTaskContentArea.taskCombo.setVariable("selectedValue", tasks[0]);
			}
			]]>
		</method>
		
		<!---
			Close the dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			if (this.taskSelectionHandler != null && this.taskSelectionHandler.cancelChangeTask && this.isCancelAction) {
				this.taskSelectionHandler.cancelChangeTask();
			}
			this.inherited(arguments);
			this.taskSelectionHandler = null;
			this.isCancelAction = true;
			this.selectTaskContentArea.taskCombo.setValues(null);	
			]]>
		</method>

		<!---
			Trigger change task.
		-->
		<method name="handleOK">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/ChangeTaskConfirmationDialog handleOK");
			this.taskSelectionHandler.changeTask(this.selectTaskContentArea.taskCombo.selectedValue, true);
			this.isCancelAction = false;
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
		
		<Component name="selectTaskContentArea">
			<AxisLayout axis="y" spacing="10"/>
			<TextComponent multiline="true" name="text" text="${foundationResources.Singleton.selectTaskDialogPrompt.string}" width="325"/>
			<!-- The combobox populated with editable columns -->
			<BaseComboBox name="taskCombo"/>
		</Component>

		<Component name="footerView" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="cancelBtn" text="${foundationResources.Singleton.simpleDialogCancel.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button name="okBtn" text="${foundationResources.Singleton.simpleDialogOK.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleOK();
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
		</Component>
	</Dialog>
</Definitions>