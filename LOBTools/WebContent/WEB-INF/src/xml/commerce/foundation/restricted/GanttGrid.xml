<?xml version="1.0" encoding="UTF-8"?>

<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<Definitions>

	<StandardStyle definitionName="cmc/foundation/GanttChartStyle" singletonDefinition="true"/>
	<!---
		@keywords private
	 -->
	<GridColumn classDefinition="true" definitionName="cmc/foundation/GanttGridBar" draggable="false" resizable="false" sortable="false" titleVisible="false">
		<dependency localName="CallbackUtil" moduleName="cmc/foundation/CallbackUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<handler name="oninit">
			<![CDATA[
			this.updateColumnWidthDel = new EventHandler.Class(this, "updateColumnWidth");
			this.updateColumnWidthDel.connect(this.parent.clippedContent, "onwidth");
			this.updateColumnWidthDel.connect(this.parent.clippedContent.gridContent, "onwidth");
			this.updateColumnWidthDel.connect(this.parent, "onavailableWidth");
			this.updateColumnWidthCallbackDel = new EventHandler.Class(this, "updateColumnWidthCallback");
			this.updateColumnWidthCallback();
			this.parent.updateHorizontalDimensions();
			]]>
		</handler>
		
		<!--- @keywords private -->
		<method args="newPropertyName" name="setPropertyName">
			<![CDATA[
			this.propertyName = newPropertyName;
			]]>
		</method>

		<!--- @keywords private -->
		<method args="newObjectPath" name="setObjectPath">
			<![CDATA[
			this.objectPath = newObjectPath;
			]]>
		</method>

		<!--- @keywords private -->
		<method name="getCellDescriptorMap">
			<![CDATA[
			if (this.cellDescriptorMap == null) {
				this.cellDescriptorMap = this.parent.getCellDescriptorMap();
			}
			return this.cellDescriptorMap;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="e" name="updateColumnWidth">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			CallbackUtil.Singleton.addDeferredCallback(this.updateColumnWidthCallbackDel, null, CallbackUtil.Singleton.PRIORITY_FOREGROUND);
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="e" name="updateColumnWidthCallback">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var deltaWidth = (this.parent.availableWidth != null ? this.parent.availableWidth : this.parent.clippedContent.width) - this.parent.clippedContent.gridContent.width;
			var newWidth = this.width + deltaWidth;
			var minimumWidth = this.parent.showHorizontalScrollbar ? this.minwidth : 0;
			newWidth = newWidth >= minimumWidth ? newWidth : minimumWidth;
			if (newWidth != this.width) {
				this.setVariable("width", newWidth);
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.updateColumnWidthDel.disconnectAll();
			delete this.updateColumnWidthDel;
			this.inherited(arguments);
			]]>
		</method>
	</GridColumn>

	<!--- @keywords private -->
	<Component classDefinition="true" definitionName="cmc/foundation/GanttGridBarViewer" height="8" valign="middle">
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="GanttChartStyle" moduleName="cmc/foundation/GanttChartStyle"/>
		<variable name="property" value="${null}"/>
		<variable name="property2" value="${null}"/>
		
		<handler name="oninit">
			<![CDATA[
			this.immediateParent.setVariable("height", this.height);
			if (this.parent.grid.visibleStartDate && this.parent.grid.visibleEndDate) {
				this.updateBar();
			}
			]]>
		</handler>
		
		<method args="newProperty" name="setProperty">
			<![CDATA[
			if (newProperty != this.property) {
				if (typeof (this.updateValueDel) == "undefined") {
					this.updateValueDel = new EventHandler.Class(this, "updateValue");
				}
				this.updateValueDel.disconnectAll();
				this.property = newProperty;
				if (this.property) {
					this.updateValueDel.connect(this.property, "onvalue");
					this.updateValueDel.connect(this.property, "ondirty");
					this.updateValue();
				}
			}
			var newProperty2 = null;
			if (this.parent.row.o) {
				var cellDescriptor = this.parent.column.getCellDescriptor(this.parent.row.o, this.updateValueDel);
				newProperty2 = this.parent.row.o.getProperty(cellDescriptor.propertyName2, cellDescriptor.objectPath);
			}
			if (newProperty2 != this.property2) {
				this.setProperty2(newProperty2);
			}
			]]>
		</method>
		
		<method args="newProperty2" name="setProperty2">
			<![CDATA[
			if (newProperty2 != this.property2) {
				if (typeof (this.updateValue2Del) == "undefined") {
					this.updateValue2Del = new EventHandler.Class(this, "updateValue2");
				}
				this.updateValue2Del.disconnectAll();
				this.property2 = newProperty2;
				if (this.property2) {
					this.updateValue2Del.connect(this.property2, "onvalue");
					this.updateValue2Del.connect(this.property2, "ondirty");
					this.updateValue2();
				}
			}
			]]>
		</method>

		<method args="e" name="updateValue">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.startDateStr != this.property.value) {
				this.setVariable("startDateStr", this.property.value);
			}
			]]>
		</method>
		
		<method args="e" name="updateValue2">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.endDateStr != this.property2.value) {
				this.setVariable("endDateStr", this.property2.value);
			}
			]]>
		</method>

		<handler eventSource="this.parent.grid" name="dateRangeChanged">
			<![CDATA[
			this.updateBar();
			]]>
		</handler>
		
		<handler name="onstartDate">
			<![CDATA[
			if (this.parent.grid.visibleStartDate && this.parent.grid.visibleEndDate) {
				this.updateBar();
			}
			]]>
		</handler>
		
		<handler name="onendDate">
			<![CDATA[
			if (this.parent.grid.visibleStartDate && this.parent.grid.visibleEndDate) {
				this.updateBar();
			}
			]]>
		</handler>
		
		<method name="updateBar">
			<![CDATA[
			var startDiff = DateUtil.Singleton.datedaysdiff(this.startDate, this.parent.grid.visibleStartDate);
			var endDiff = DateUtil.Singleton.datedaysdiff(this.endDate, this.parent.grid.visibleStartDate);
			var relStartDiff = (startDiff != null && startDiff >= 0) ? startDiff : 0;
			var relNumDays = endDiff != null ? (endDiff - relStartDiff + 1) : null;
			this.bar.setVariable('x', relStartDiff * this.parent.grid.widthPerDay - this.parent.content.x);
			var newWidth = 0;
			if (this.parent.column.width > this.bar.x) {
				if (relNumDays != null) {
					if (relNumDays >= 0) {
						newWidth = Math.min((this.parent.column.width - this.bar.x), (relNumDays * this.parent.grid.widthPerDay));
					}
				}
				else {
					newWidth = this.parent.column.width - this.bar.x;
				}
			}
			this.bar.setVariable('width', newWidth);
			]]>
		</method>
				
		<variable name="startDateStr" type="string" value=""/>
		<variable name="endDateStr" type="string" value=""/>
		
		<variable name="startDate" value="${DateUtil.Singleton.parse(this.startDateStr, DateUtil.Singleton.DATE_FORMAT)}"/>
		<variable name="endDate" value="${DateUtil.Singleton.parse(this.endDateStr, DateUtil.Singleton.DATE_FORMAT)}"/>
		
		<Component bgcolor="${GanttChartStyle.Singleton.ganttbarcolor}" height="8" name="bar"/>

		<method args="property" name="set_property">
			<![CDATA[
			this.setProperty(property);
			]]>
		</method>
	</Component>

	<!---
		@keywords abstract
		<p>
		cmc/foundation/GanttGrid is a specialized {@link cmc/foundation/ObjectGrid} with Gantt chart capabilities. Columns and filters are added in the same way but a Gantt
		chart shows up as a column at the end of the grid without being specified. cmc/foundation/GanttGrid and classes that extend cmc/foundation/GanttGrid must not be
		instantiated directly. 	They may only be declared as the "listClass" for {@link cmc/foundation/ChildListEditor}, {@link cmc/foundation/SearchDefinition} and
		{@link cmc/foundation/ReferenceList}. The framework will determine when the list view is required and instantiate the specified cmc/foundation/GanttGrid class to
		display a list of business objects. The grid instance will create a row for every object in the list of business objects.
		Each row in a grid can display the start date and end date of an object. For example, a promotion has a start date and
		an end date, therefore a Gantt grid can be used to show the date range of a list of promotions.
		</p><p>
		The following code creates a Gantt grid that displays a list of objects of the same type which uses the startDate and endDate names for the
		Gantt chart date range. startDatePropertyName and endDatePropertyName attributes are used here to specify these property names.
		</p><p>
		@START_CODE
			<GanttGrid definitionName="sampleGanttGrid" startDatePropertyName="startDate" endDatePropertyName="endDate">
				<GridIconTypeImage name="type" text="${resources.type}" width="60" required="true"/>
				<GridText name="uniqueID" propertyName="Id" editable="false" text="${resources.uniqueID}"
					visible="false" width="90" datatype="number"/>
			</GanttGrid>
		@END_CODE
		</p><p>
		The next example shows the same Gantt grid but displays a list of objects of more than one type with differnt start and end date
		properties.  This is accomplished by using the {@link cmc/foundation/GanttGridBarDescriptor} instead of startDatePropertyName and
		endDatePropertyName.  Below sampleObject1 has a different start and end date property names than sampleObject2.
		</p><p>
		@START_CODE
			<GanttGrid definitionName="sampleGanttGrid">
	`			<GanttGridBarDescriptor objectType="sampleObject1" propertyName="startDate" propertyName2="endDate"/>
				<GanttGridBarDescriptor objectType="sampleObject2" propertyName="beginDate" propertyName2="finishDate"/>
				
				<GridIconTypeImage name="type" text="${resources.type}" width="60" required="true"/>
				<GridText name="uniqueID" propertyName="Id" editable="false" text="${resources.uniqueID}"
					visible="false" width="90" datatype="number"/>
			</GanttGrid>
		@END_CODE
		</p>
	 -->
	<ObjectGrid classDefinition="true" definitionName="cmc/foundation/GanttGrid" showDummyColumn="false" showHorizontalScrollbar="false" showvlines="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="GanttGridBarViewer" moduleName="cmc/foundation/GanttGridBarViewer"/>
		<dependency localName="GanttGridFooter" moduleName="cmc/foundation/GanttGridFooter"/>
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
		<dependency localName="GanttGridBarDescriptor" moduleName="cmc/foundation/GanttGridBarDescriptor"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="GridCellDescriptorMap" moduleName="cmc/foundation/GridCellDescriptorMap"/>
		<dependency localName="EventUtil" moduleName="cmc/foundation/EventUtil"/>
		<dependency localName="PreferenceManager" moduleName="cmc/shell/PreferenceManager"/>
		<!---
			@keywords private
			Reference to a class that can be used to implement the footer of this grid.
		-->
		<variable name="footerClass" value="${GanttGridFooter}"/>
	
		<!---
			The initial range, in days, for the calendar view.
			The default value is 90 days.  The calendar displays 30 days before and 60 days after the current day.
		 -->
		<variable name="range" type="number" value="90"/>
	
		<!---
			@keywords private
			The start date visible to a user.
		-->
		<variable name="visibleStartDate" value="${null}"/>
		
		<!---
			@keywords private
			The end date visible to a user.
		-->
		<variable name="visibleEndDate" value="${null}"/>
		
		<!---
			@keywords private
			The number of days visible to a user.
		-->
		<variable name="visibleDays" type="number" value="1"/>
		
		<!---
			@keywords private
			The width each day can have when displayed.
		-->
		<variable name="widthPerDay" type="number" value="0"/>
		
	
		<!---
			This attribute is used to specify the path that is used to locate the properties defined in the startDatePropertyName
			and endDatePropertyName attributes. In other words dateObjectPath is used to find a child Management Center object
			relative to the current object. If the property applies to the current object, then you do not need
			to specify an dateObjectPath.
		-->
		<variable name="dateObjectPath" type="string" value="${null}"/>
		
		<!---
			The property that contains the start date of the object.  This is the default start date property.  It is a required attribute
			unless a {@link cmc/foundation/GanttGridBarDescriptor} is defined.
		-->		
		<variable name="startDatePropertyName" type="string" value="startdate"/>
		
		<!---
			The property that contains the end date of the object. This is the default end date property.  It is a required attribute
			unless a {@link cmc/foundation/GanttGridBarDescriptor} is defined.
		-->
		<variable name="endDatePropertyName" type="string" value="enddate"/>
		
		<!---
			The minimum width of the Gantt bar column. This value is only used if showHorizontalScrollbar is set to
			true.
		-->
		<variable name="ganttBarMinWidth" type="number" value="200"/>
		
		<!---
			@keywords private
			A map that stores all the descriptors for each cell. See {@link cmc/foundation/CellDescriptorMap}
			for details.
		-->
		<variable name="cellDescriptorMap" value="${null}"/>
		<!---
			@keywords private
			This attribute specifies the name of the view class used to create cell viewer for the Gantt grid bar.
			@type string
		-->
		<variable name="cellViewerClass" type="module" value="${GanttGridBarViewer}"/>
		<!---
			@keywords private
			This attribute specifies the name of the view class used to create editor instances for the Gantt grid bar.
			@type string
		-->
		<variable name="cellEditorClass" type="module" value="${null}"/>
		
		<!--- @keywords private	 -->
		<method name="postCreateDefinitionChildren">
			<![CDATA[
			if (this.preferenceKey == null || PreferenceManager.Singleton.getPreference(this.preferenceKey) == null) {
				this.setColumnPosition(this.ganttBar, this.columns.length, true);
			}
			this.updateGanttAxisWidthDel = new EventHandler.Class(this, "updateGanttAxisWidth");
			this.updateGanttAxisXDel = new EventHandler.Class(this, "updateGanttAxisX");
			this.updateGanttBarsDel = new EventHandler.Class(this, "updateGanttBars");
			this.updateGanttAxisSpaceDel = new EventHandler.Class(this, "updateGanttAxisSpace");
			this.registerResizers();
			this.updateGanttAxisSpace(false);
			this.inherited(arguments);
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.updateGanttAxisWidthDel.disconnectAll();
			delete this.updateGanttAxisWidthDel;
			this.updateGanttAxisXDel.disconnectAll();
			delete this.updateGanttAxisXDel;
			this.updateGanttBarsDel.disconnectAll();
			delete this.updateGanttBarsDel;
			this.updateGanttAxisSpaceDel.disconnectAll();
			delete this.updateGanttAxisSpaceDel;
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			@keywords private
			@return cmc/foundation/CellDescriptorMap cell descriptor map owned by this grid. If no descriptor map is found, a default one
				will be created and returned.
		-->
		<method name="getCellDescriptorMap">
			<![CDATA[
			if (this.cellDescriptorMap == null) {
				this.cellDescriptorMap = new GridCellDescriptorMap.Class(this);
				new GanttGridBarDescriptor.Class(this, {
					_default: true,
					objectType: null,
					objectPath: this.dateObjectPath,
					propertyName: this.startDatePropertyName,
					propertyName2: this.endDatePropertyName
				});
			}
			return this.cellDescriptorMap;
			]]>
		</method>
		
		<!---
			@keywords private
			Finds the cell description that matches the given object definition.
			@param cmc/foundation/ModelObject the object that matches the found cell descriptor.
				See {@link cmc/foundation/CellDescriptorMap#getCellDescriptor} for details.
		-->
		<method args="object, delegate" name="getCellDescriptor">
			<![CDATA[
			if (typeof(delegate) == "undefined") delegate = null;
			var cellDescriptor = null;
			var multipleMatch = false;
			var cellDescriptors = this.getCellDescriptorMap().getCellDescriptors(object, delegate);
			for (var i = 0; i < cellDescriptors.length; i++) {
				var objects = object.getObjects(cellDescriptors[i].objectPath, null, null, true);
				if (objects.length > 1) {
					cellDescriptor = null;
					multipleMatch = true;
				}
				if (!multipleMatch && objects.length == 1) {
					if (cellDescriptor) {
						cellDescriptor = null;
						multipleMatch = true;
					}
					else {
						cellDescriptor = cellDescriptors[i];
					}
				}
			}
			if (cellDescriptor == null && !multipleMatch && cellDescriptors.length == 1 && this.implicitCreate) {
				cellDescriptor = cellDescriptors[0];
			}
			return cellDescriptor;
			]]>
		</method>
		
		<!---
			@keywords private
			Override this method to return additional initialization arguments for that will be used to create the viewer.
			@return object additional initialization arguments
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return null;
			]]>
		</method>

		<!---
			@keywords private
			Rescales this grid based on the given visible start date and the end date. See
			{@link cmc/foundation/GanttAxis#render} for how the scaling is performed. The bar of the
			Gantt grid will be updated too by calling {@link cmc/foundation/GanttGrid#updateGanttBars}.
			@param Date p_visibleStartDate the new visible start date for rescaling
			@param Date p_visibleEndDate the new visible end date for rescaling.
		 -->
		<method args="p_visibleStartDate, p_visibleEndDate" name="rescale">
			<![CDATA[
			this.visibleStartDate = p_visibleStartDate;
			this.visibleEndDate = p_visibleEndDate;
			this.ganttAxis.setVariable("startDate", this.visibleStartDate);
			this.ganttAxis.setVariable("endDate", this.visibleEndDate);
			this.ganttAxis.render();
			this.updateGanttBars();
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the bar of this grid based. Each day will have the same width. The sum of the width
			of every visible day will be equal to the the width of the bar.
			@event dateRangeChanged
		 -->
		<method args="e" name="updateGanttBars">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.visibleDays = DateUtil.Singleton.datedaysdiff(this.visibleEndDate, this.visibleStartDate) + 1;
			this.widthPerDay = this.ganttBar.width / this.visibleDays;
			EventUtil.trigger(this, "dateRangeChanged");
			]]>
		</method>
		
		<!---
			@keywords private
			Registers the this.updateGanttAxisSpaceDel to the onresizing event of each column's resizer view.
		 -->
		<method name="registerResizers">
			<![CDATA[
			for (var i = 0; i < this.columns.length; i++) {
				this.updateGanttAxisSpaceDel.connect(this.columns[i].resizer, "onresizing");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the spaces in Gantt axis.
			@param boolean resizing true if the grid is in the middle of resizing, in which case the bar will be hidden.
				Otherwise, this grid will be resized.
		 -->
		<method args="resizing" name="updateGanttAxisSpace">
			<![CDATA[
			if (resizing) {
				this.updateGanttAxisXDel.disconnectAll();
				this.updateGanttAxisWidthDel.disconnectAll();
				this.updateGanttBarsDel.disconnectAll();
				this.ganttAxis.setVariable("visible", false);
			}
			else {
				this.updateGanttAxisXDel.connect(this.ganttBar, "onx");
				this.updateGanttAxisXDel.connect(this.clippedContent.gridContent, "onx");
				this.updateGanttAxisWidthDel.connect(this.ganttBar, "onwidth");
				this.updateGanttBarsDel.connect(this.ganttBar, "onwidth");
				this.updateGanttAxisX();
				this.updateGanttAxisWidth();
				this.ganttAxis.render();
				this.updateGanttBars();
				this.ganttAxis.setVariable("visible", true);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Vertically aligns the Gantt axis and the Gantt bar.
		 -->
		<method args="e" name="updateGanttAxisX">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.ganttAxis.setVariable("x", this.ganttBar.x + (this.showPrefixColumn ? 15 : 0) + this.clippedContent.gridContent.x);
			]]>
		</method>
		
		<!---
			@keywords private
			Sychronizes the width of the Gantt axis with that of Gantt bar.
		 -->
		<method args="e" name="updateGanttAxisWidth">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.ganttAxis.setVariable("width", this.ganttBar.width);
			]]>
		</method>
		
		<GanttAxis clip="true" height="${this.parent.clippedContent.height}" ignoreLayout="true" marginWidth="20" name="ganttAxis" placement="${parent}" y="${this.parent.clippedContent.y}"/>
		
		<GanttGridBar minwidth="${this.parent.ganttBarMinWidth}" name="ganttBar" required="true" text="${foundationResources.Singleton.ganttBarTitle.string}" visible="true" width="600"/>
	</ObjectGrid>
	
	<!--- @keywords private -->
	<Component classDefinition="true" definitionName="cmc/foundation/GanttGridFooter" width="${this.parent.width}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
		<dependency localName="GanttGridFilter" moduleName="cmc/foundation/GanttGridFilter"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="FocusIndicator" moduleName="cmc/foundation/FocusIndicator"/>
		<dependency localName="GanttChartStyle" moduleName="cmc/foundation/GanttChartStyle"/>
		<variable name="grid"/>
	
		<variable name="totalsArea" value="${this.content.bottomArea.bottomAreaParent.totalsAreaParent.totalsArea}"/>
		<variable name="fromDateInput" value="${this.content.bottomArea.bottomAreaParent.summaryView.daterange.dates.fromdate}"/>
		<variable name="toDateInput" value="${this.content.bottomArea.bottomAreaParent.summaryView.daterange.dates.todate}"/>
		
		<variable name="ganttGridFilter" value="${null}"/>

		<variable name="__totalsAreaInited" type="boolean" value="false"/>
		
		<variable name="summaryViewWidth" type="number" value="300"/>
		
		<variable name="barareavisible" type="boolean" value="true"/>
		
		<method name="init">
			<![CDATA[
			this.content.bottomArea.bottomAreaParent.totalsAreaParent.ganttControl = this;
			this.content.bottomArea.bottomAreaParent.summaryView.ganttControl = this;
			this.updatePositionsAndWidthDel = new EventHandler.Class(this, "updatePositionsAndWidth");
			this.updateRegisterSizeDelegatesDel = new EventHandler.Class(this, "updateRegisterSizeDelegates");
			this.registerResizers();
			this.updateRegisterSizeDelegates(false);
			if (this.oListUpdatedDel) {
				this.oListUpdatedDel.disconnectAll();
			}
			else {
				this.oListUpdatedDel = new EventHandler.Class(this, "oListUpdated");
			}
			this.oListUpdatedDel.connect(this.grid, "onoList");
			this.oListUpdated();
			this.inherited(arguments);
			]]>
		</method>
		
		<method name="registerResizers">
			<![CDATA[
			for (var i = 0; i < this.grid.columns.length; i++) {
				this.updateRegisterSizeDelegatesDel.connect(this.grid.columns[i].resizer, "onresizing");
			}
			]]>
		</method>
		
		<method args="resizing" name="updateRegisterSizeDelegates">
			<![CDATA[
			if (resizing) {
				this.updatePositionsAndWidthDel.disconnectAll();
			}
			else {
				this.updatePositionsAndWidthDel.connect(this.grid, "onwidth");
				this.updatePositionsAndWidth();
			}
			]]>
		</method>
		
		<method args="e" name="updatePositionsAndWidth">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.content.bottomArea.bottomAreaParent.totalsAreaParent.setVariable("width", Math.max(this.grid.width - this.summaryViewWidth, 300));
			]]>
		</method>
			
		<method args="e" name="oListUpdated">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.grid.oList) {
				var rangeBeforeToday = Math.round(this.grid.range / 3);
				var todaysDate = new Date();
				var selectedStartDate = DateUtil.Singleton.copydate(todaysDate);
				DateUtil.Singleton.adddays(selectedStartDate, -rangeBeforeToday);
				var selectedEndDate = DateUtil.Singleton.copydate(todaysDate);
				DateUtil.Singleton.adddays(selectedEndDate, this.grid.range - rangeBeforeToday);
				if (this.modelObjectsUpdatedDel) {
					this.modelObjectsUpdatedDel.disconnectAll();
				}
				else {
					this.modelObjectsUpdatedDel = new EventHandler.Class(this, "modelObjectsUpdated");
				}
				this.modelObjectsUpdatedDel.connect(this.grid.oList, "onmodelObjects");
				this.modelObjectsUpdated();
				this.updatevisiblelist(selectedStartDate, selectedEndDate);
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.oListUpdatedDel.disconnectAll();
			delete this.oListUpdatedDel;
			this.updatePositionsAndWidthDel.disconnectAll();
			delete this.updatePositionsAndWidthDel;
			this.updateRegisterSizeDelegatesDel.disconnectAll();
			delete this.updateRegisterSizeDelegatesDel;
			this.inherited(arguments);
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="addDays" name="rescaleDateRange">
			<![CDATA[
			var newSelectedEndDate = DateUtil.Singleton.copydate(this.totalsArea.selectedStartDate);
			DateUtil.Singleton.adddays(newSelectedEndDate, addDays);
			this.totalsArea.updateSelectedDates(this.totalsArea.selectedStartDate, newSelectedEndDate);
			]]>
		</method>
	
		<Component name="content" width="${this.parent.width}">
			<Component name="vdivider" width="${this.parent.width}" x="0" y="8">
				<Component focusable="true" name="hideToggleView">
					<AxisLayout axis="x" inset="8" spacing="8"/>
					<Component name="toggleViewButton" imageSet="propertyDrawerResource" x="5" currentImage="${this.classroot.barareavisible ? 2 : 1}" y="3"/>
					<TextComponent text="${this.classroot.barareavisible ? foundationResources.Singleton.hide.string : foundationResources.Singleton.show.string}" fontsize="15" fontstyle="bold"/>
					
					<!--- @keywords private -->
					<handler name="onclick">
						<![CDATA[
						this.classroot.setVariable("barareavisible", !this.classroot.barareavisible);
						]]>
					</handler>
					
					<!--- @keywords private -->
					<handler args="k" name="onkeydown">
						<![CDATA[
						if (k == 13 || k == 32) {
							this.classroot.setVariable("barareavisible", !this.classroot.barareavisible);
						}
						]]>
					</handler>
					
					<!--- @keywords private -->
					<handler name="onfocus">
						<![CDATA[
						if (!this.indicator) {
							new FocusIndicator.Class(this, {
								name: "indicator",
								focusableView: this,
								indicatorView: this.toggleViewButton
							});
						}
						]]>
					</handler>
				</Component>
			</Component>
			<Component clip="true" height="${this.classroot.barareavisible ? this.bottomAreaParent.height : 28}" name="bottomArea" y="${this.classroot.content.vdivider.y + this.classroot.content.vdivider.height}">
			
				<Component name="bottomAreaParent" y="${this.classroot.barareavisible ? 0 : -55}">
			
					<Component clip="true" name="totalsAreaParent" x="${this.classroot.summaryViewWidth}" bgcolor="${GanttChartStyle.Singleton.ganttfiltercontrolsbackground}" visible="${this.classroot.barareavisible}">
						<handler name="onwidth">
							<![CDATA[
							if (this.classroot.__totalsAreaInited) {
								this.classroot.updateTotalsPosition();
							}
							]]>
						</handler>
						<GanttTotalsArea ganttControl="${this.classroot}" name="totalsArea"/>
						<AxisLayout axis="y" inset="20" spacing="20"/>
					</Component>
				
					<Component bgcolor="${GanttChartStyle.Singleton.ganttfiltercontrolsbackground}" height="${this.classroot.content.bottomArea.bottomAreaParent.totalsAreaParent.height}" name="summaryView" width="${this.classroot.summaryViewWidth}" x="0">
						<AxisLayout axis="y"/>
						<Component height="8"/>
						<Component name="daterange" visible="${this.classroot.barareavisible}" x="25">
							<AxisLayout axis="y" spacing="10"/>
							<TextComponent text="${foundationResources.Singleton.range.string}"/>
							<Component name="dates">
								<AxisLayout axis="x" spacing="15"/>
								<DatePicker name="fromdate">
									<method name="storeValue">
										<![CDATA[
										this.inherited(arguments);
										var newSelectedStartDate = this.getDate();
										if (newSelectedStartDate != this.classroot.totalsArea.selectedStartDate) {
											if (newSelectedStartDate) {
												this.classroot.totalsArea.updateSelectedDates(newSelectedStartDate, this.classroot.totalsArea.selectedEndDate);
											}
											else {
												this.setDate(this.classroot.totalsArea.selectedStartDate);
											}
										}
										]]>
									</method>
								</DatePicker>
								<DatePicker name="todate">
									<method name="storeValue">
										<![CDATA[
										this.inherited(arguments);
										var newSelectedEndDate = this.getDate();
										if (newSelectedEndDate != this.classroot.totalsArea.selectedEndDate) {
											if (newSelectedEndDate) {
												this.classroot.totalsArea.updateSelectedDates(this.classroot.totalsArea.selectedStartDate, newSelectedEndDate);
											}
											else {
												this.setDate(this.classroot.totalsArea.selectedEndDate);
											}
										}
										]]>
									</method>
								</DatePicker>
							</Component>
						</Component>
						<Component height="24"/>
						<Component name="presetLinks" x="25">
							<AxisLayout axis="y" spacing="10"/>
							<TextComponent text="${foundationResources.Singleton.scale.string}"/>
							<Component name="rescaleLinks" fgcolor="#037bbf">
								<AxisLayout axis="x" spacing="32"/>
								<TextComponent focusable="true" text="${'&lt;u&gt;' + foundationResources.Singleton.oneWeekLink.string + '&lt;/u&gt;'}" visible="${(this.classroot.content.bottomArea.bottomAreaParent.totalsAreaParent.width / 2) &gt; 7}">
								
									<!--- @keywords private -->
									<method name="rescaleClicked">
										<![CDATA[
										this.classroot.rescaleDateRange(6);
										]]>
									</method>

									<!--- @keywords private -->
									<handler args="k" name="onkeydown">
										<![CDATA[
										if (k == 13 || k == 32) {
											this.classroot.rescaleDateRange(6);
										}
										]]>
									</handler>
									
									<!--- @keywords private -->
									<handler name="onfocus">
										<![CDATA[
										if (!this.indicator) {
											new FocusIndicator.Class(this, {
												name: "indicator",
												focusableView: this,
												indicatorView: this
											});
										}
										]]>
									</handler>
									
									<handler name="onclick">
										<![CDATA[
										this.rescaleClicked();
										]]>
									</handler>
								</TextComponent>
								<TextComponent focusable="true" text="${'&lt;u&gt;' + foundationResources.Singleton.oneMonthLink.string + '&lt;/u&gt;'}" visible="${(this.classroot.content.bottomArea.bottomAreaParent.totalsAreaParent.width / 2) &gt; 30}">

									<!--- @keywords private -->
									<method name="rescaleClicked">
										<![CDATA[
										this.classroot.rescaleDateRange(30);
										]]>
									</method>

									<!--- @keywords private -->
									<handler args="k" name="onkeydown">
										<![CDATA[
										if (k == 13 || k == 32) {
											this.classroot.rescaleDateRange(30);
										}
										]]>
									</handler>
									
									<!--- @keywords private -->
									<handler name="onfocus">
										<![CDATA[
										if (!this.indicator) {
											new FocusIndicator.Class(this, {
												name: "indicator",
												focusableView: this,
												indicatorView: this
											});
										}
										]]>
									</handler>

									<handler name="onclick">
										<![CDATA[
										this.rescaleClicked();
										]]>
									</handler>
								</TextComponent>
								<TextComponent focusable="true" text="${'&lt;u&gt;' + foundationResources.Singleton.threeMonthsLink.string + '&lt;/u&gt;'}" visible="${(this.classroot.content.bottomArea.bottomAreaParent.totalsAreaParent.width / 2) &gt; 90}">

									<!--- @keywords private -->
									<method name="rescaleClicked">
										<![CDATA[
										this.classroot.rescaleDateRange(90);
										]]>
									</method>

									<!--- @keywords private -->
									<handler args="k" name="onkeydown">
										<![CDATA[
										if (k == 13 || k == 32) {
											this.classroot.rescaleDateRange(90);
										}
										]]>
									</handler>
									
									<!--- @keywords private -->
									<handler name="onfocus">
										<![CDATA[
										if (!this.indicator) {
											new FocusIndicator.Class(this, {
												name: "indicator",
												focusableView: this,
												indicatorView: this
											});
										}
										]]>
									</handler>
									
									<handler name="onclick">
										<![CDATA[
										this.rescaleClicked();
										]]>
									</handler>
								</TextComponent>
								<TextComponent focusable="true" text="${'&lt;u&gt;' + foundationResources.Singleton.sixMonthsLink.string + '&lt;/u&gt;'}" visible="${(this.classroot.content.bottomArea.bottomAreaParent.totalsAreaParent.width / 2) &gt; 180}">

									<!--- @keywords private -->
									<method name="rescaleClicked">
										<![CDATA[
										this.classroot.rescaleDateRange(180);
										]]>
									</method>

									<!--- @keywords private -->
									<handler args="k" name="onkeydown">
										<![CDATA[
										if (k == 13 || k == 32) {
											this.classroot.rescaleDateRange(180);
										}
										]]>
									</handler>
									
									<!--- @keywords private -->
									<handler name="onfocus">
										<![CDATA[
										if (!this.indicator) {
											new FocusIndicator.Class(this, {
												name: "indicator",
												focusableView: this,
												indicatorView: this
											});
										}
										]]>
									</handler>
									
									<handler name="onclick">
										<![CDATA[
										this.rescaleClicked();
										]]>
									</handler>
								</TextComponent>
								<TextComponent focusable="true" text="${'&lt;u&gt;' + foundationResources.Singleton.oneYearLink.string + '&lt;/u&gt;'}" visible="${(this.classroot.content.bottomArea.bottomAreaParent.totalsAreaParent.width / 2) &gt; 365}">

									<!--- @keywords private -->
									<method name="rescaleClicked">
										<![CDATA[
										this.classroot.rescaleDateRange(365);
										]]>
									</method>

									<!--- @keywords private -->
									<handler args="k" name="onkeydown">
										<![CDATA[
										if (k == 13 || k == 32) {
											this.classroot.rescaleDateRange(365);
										}
										]]>
									</handler>
									
									<!--- @keywords private -->
									<handler name="onfocus">
										<![CDATA[
										if (!this.indicator) {
											new FocusIndicator.Class(this, {
												name: "indicator",
												focusableView: this,
												indicatorView: this
											});
										}
										]]>
									</handler>
									
									<handler name="onclick">
										<![CDATA[
										this.rescaleClicked();
										]]>
									</handler>
								</TextComponent>
							</Component>
						</Component>
					</Component>
				</Component>
			</Component>
		</Component>
		
		<method args="visibleStartDate, visibleEndDate" name="rescale">
			<![CDATA[
			this.fromDateInput.setDate(visibleStartDate);
			this.toDateInput.setDate(visibleEndDate);
			this.grid.rescale(visibleStartDate, visibleEndDate);
			]]>
		</method>

		
		<method args="visibleStartDate, visibleEndDate" name="updatevisiblelist">
			<![CDATA[
			if (!this._updatingVisibleList) {
				this._updatingVisibleList = true;
				if (this.grid.oList != null) {
					if (this.ganttGridFilter == null) {
						this.ganttGridFilter = new GanttGridFilter.Class(this, {
							filterType: "wcfDateRangeGanttFilter",
							ganttGrid: this.grid
						});
					}
					this.ganttGridFilter.visibleStartDate = DateUtil.Singleton.getTimeDay(visibleStartDate);
					this.ganttGridFilter.visibleEndDate = DateUtil.Singleton.getTimeDay(visibleEndDate);
					var filterList = this.grid.oList.filterList;
					if (!filterList) {
						filterList = [];
					}
					var ganttFilterFound = false;
					for (var i = 0; i < filterList.length; i++) {
						if (this.ganttGridFilter == filterList[i]) {
							ganttFilterFound = true;
							break;
						}
					}
					if (ganttFilterFound) {
						this.grid.oList.refreshFilteredObjects();
					}
					else {
						filterList.push(this.ganttGridFilter);
						this.grid.oList.setVariable("filterList", filterList);
					}
				}
				this.rescale(visibleStartDate, visibleEndDate);
				if (!this.__totalsAreaInited) {
					this.totalsArea.setVariable("selectedStartDate", visibleStartDate);
					this.totalsArea.setVariable("selectedEndDate", visibleEndDate);
				}
				this.updateTotalsPosition();
				this._updatingVisibleList = false;
			}
			]]>
		</method>
		
		<method name="updateTotalsPosition">
			<![CDATA[
			var newX = -1;
			if (this.__totalsAreaInited) {
				newX = Math.round(this.totalsArea.getLeftX() - ((this.totalsArea.parent.width - this.totalsArea.getRightX() + this.totalsArea.getLeftX()) / 2));
			}
			if (newX < 0 || (this.totalsArea.width - newX) < this.totalsArea.parent.width) {
				this.updateTotalsAreaDateRange();
				var oldX = newX;
				newX = Math.round(this.totalsArea.getLeftX() - ((this.totalsArea.parent.width - this.totalsArea.getRightX() + this.totalsArea.getLeftX()) / 2));
				this.totalsArea.setVariable('x', this.totalsArea.x + oldX - newX + 1);
			}
			var delta = Math.abs(newX - (this.totalsArea.x * -1));
			this.totalsArea.animate("x", -newX, 5 * delta);
			]]>
		</method>
		
		<method name="updateTotalsAreaDateRange">
			<![CDATA[
			var selectedStartDate = this.totalsArea.selectedStartDate;
			var selectedEndDate = this.totalsArea.selectedEndDate;
			var newStartDate = DateUtil.Singleton.copydate(selectedStartDate);
			DateUtil.Singleton.adddays(newStartDate, -Math.round(this.totalsArea.parent.width / 2));
			var newEndDate = DateUtil.Singleton.copydate(selectedEndDate);
			DateUtil.Singleton.adddays(newEndDate, Math.round(this.totalsArea.parent.width / 2));
			this.totalsArea.setVariable("startDate", newStartDate);
			this.totalsArea.setVariable("endDate", newEndDate);
			this.totalsArea.updateTotalsArea();
			this.__totalsAreaInited = true;
			]]>
		</method>

		<method args="e" name="modelObjectsUpdated">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.totalsArea.updateTotalsArea();
			this.registerDatePropertyUpdated();
			]]>
		</method>
		
		<method name="registerDatePropertyUpdated">
			<![CDATA[
			if (this.datePropertyUpdatedDel) {
				this.datePropertyUpdatedDel.disconnectAll();
			}
			else {
				this.datePropertyUpdatedDel = new EventHandler.Class(this, "datePropertyUpdated");
			}
			if (this.grid.oList != null) {
				var modelObjects = this.grid.oList.getMatchingModelObjects();
				for (var i = 0; i < modelObjects.length; i++) {
					var cellDescriptor = this.grid.getCellDescriptor(modelObjects[i], this.datePropertyUpdatedDel);
					if (cellDescriptor) {
						var startDateProperty = modelObjects[i].getProperty(cellDescriptor.propertyName, cellDescriptor.objectPath);
						var endDateProperty = modelObjects[i].getProperty(cellDescriptor.propertyName2, cellDescriptor.objectPath);
						this.datePropertyUpdatedDel.connect(startDateProperty, "onvalue");
						this.datePropertyUpdatedDel.connect(startDateProperty, "ondirty");
						this.datePropertyUpdatedDel.connect(endDateProperty, "onvalue");
						this.datePropertyUpdatedDel.connect(endDateProperty, "ondirty");
					}
				}
			}
			]]>
		</method>
	
		<method args="e" name="datePropertyUpdated">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.totalsArea.updateTotalsArea();
			]]>
		</method>

	</Component>
	
	<!---
		This class allows objects of different types to be displayed in the same
		instance of cmc/foundation/GanttGrid. Each object type can have different property names for
		the start and end date.
	-->
	<GridCellDescriptor classDefinition="true" definitionName="cmc/foundation/GanttGridBarDescriptor">
		<!---
			The end date property name.
		-->
		<variable name="propertyName2" type="string" value="${null}"/>
	</GridCellDescriptor>

</Definitions>