<?xml version="1.0" encoding="UTF-8"?>

<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<Definitions>
	<!---
		This class defines a grid column that shows object property values as simple text data.
		When a cell in the column changes to edit mode, then the cell will be
		replaced by an input text editor. cmc/foundation/GridText instances may only be declared as immediate
		children of instances of {@link cmc/foundation/ObjectGrid}.
		
		This column is {@link cmc/foundation/GridColumn#findable findable} and implements the required method to highlight
		and unhighlight its cells. 
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridText.
		The column will display the values of instances of the property named "object_identifier" found
		in the object instances	that are resolved using the object path "ObjectGroup/ObjectIdentifier".
		
		@START_CODE
		<GridText
			name="identifier"
			objectPath="ObjectGroup/ObjectGroupIdentifier"
			propertyName="object_identifier"
			required="true"
			editable="true"
			text="${resourceBundle.identifyObject}"
			width="90"/>
		@END_CODE
		
	-->
	<GridColumn classDefinition="true" definitionName="cmc/foundation/GridText" findable="true">
		<dependency localName="GridTextEditor" moduleName="cmc/foundation/GridTextEditor"/>
		<dependency localName="ColumnTextEditor" moduleName="cmc/foundation/ColumnTextEditor"/>
		<dependency localName="GridTextViewer" moduleName="cmc/foundation/GridTextViewer"/>
		<!---
			@keywords private
			Use {@link cmc/foundation/GridTextViewer} to create cell viewer instances.
		-->
		<variable name="cellViewerClass" value="${GridTextViewer}"/>
		<!---
			@keywords private
			Use {@link cmc/foundation/GridTextEditor} to create cell editor instances.
		-->
		<variable name="cellEditorClass" value="${GridTextEditor}"/>		
		<!---
			@keywords private
			Use "cmc/foundation/ColumnTextEditor" to create Column Editor editor.
		-->
		<variable name="columnEditorClass" value="${ColumnTextEditor}"/>
		
		<!---
			@keywords private
			This method is called by find and replace when it finds the searched for text in a cell in this column
			to apply the visual treatment to said cell.		
			@param cell cmc/foundation/GridCell The cell that contains the match.
			@param number index The index of the match in the cell.
			@param number length The length of the match in the cell. 
		-->
		<method args="cell, index, length" name="highlightWordInCell">
			<![CDATA[
			if (cell.editor) {
				cell.editor.highlightWord(index, length);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This method is called by find and replace when it wants to undo the visual treatment it did for find and 
			replace.			
			@param cell cmc/foundation/GridCell The cell to remove the formatting from.			
		-->
		<method args="cell" name="unhighlightCell">
			<![CDATA[
			if (cell.editor) {
				cell.editor.unhighlight();
			}
			]]>
		</method>	
	</GridColumn>
	
	<!---
		Use this class to show simple text data in a grid cell. Use this class instead of cmc/foundation/GridText if you
		need to display text for some rows and something else for other rows.
	-->
	<GridCellDescriptor classDefinition="true" definitionName="cmc/foundation/GridTextCellDescriptor">
		<dependency localName="GridTextEditor" moduleName="cmc/foundation/GridTextEditor"/>
		<dependency localName="GridTextViewer" moduleName="cmc/foundation/GridTextViewer"/>
		<!---
			@keywords private
			Use {@link cmc/foundation/GridTextViewer} to create cell viewer instances.
		-->
		<variable name="cellViewerClass" value="${GridTextViewer}"/>
		<!---
			@keywords private
			Use {@link cmc/foundation/GridTextEditor} to create cell editor instances.
		-->
		<variable name="cellEditorClass" value="${GridTextEditor}"/>		
	</GridCellDescriptor>
	
	<!---
		@keywords final
		This class defines a grid column that shows object property values as rich text data.
		When a cell in the column changes to edit mode a rich text editor dialog will be displayed.
		cmc/foundation/GridRichText instances may only be declared as immediate children of instances
		of {@link cmc/foundation/ObjectGrid}. Find and replace will work on columns of this type.
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridRichText.
		The column will display the values of instances of the property named "long_description" found
		in the object instances	that are resolved using the object path "ObjectGroup/ObjectGroupDescription".

		@START_CODE
		<GridRichText
			name="lDesc"
			objectPath="ObjectGroup/ObjectGroupDescription"
			propertyName="long_description"
			required="true"
			editable="true"
			text="${resourceBundle.longDescription}"
			width="200"/>
		@END_CODE
	-->
	<GridColumn classDefinition="true" definitionName="cmc/foundation/GridRichText" findable="true" tagsRemoved="true">
		<dependency localName="GridRichTextViewer" moduleName="cmc/foundation/GridRichTextViewer"/>
		<dependency localName="ColumnRichTextEditor" moduleName="cmc/foundation/ColumnRichTextEditor"/>
		<dependency localName="GridRichTextEditor" moduleName="cmc/foundation/GridRichTextEditor"/>
		<!---
			@keywords private
			Use {@link cmc/foundation/GridRichTextViewer} to create cell viewer instances.
		-->
		<variable name="cellViewerClass" value="${GridRichTextViewer}"/>
		<!---
			@keywords private
			Use {@link cmc/foundation/GridRichTextEditor} to create cell editor instances.
		-->
		<variable name="cellEditorClass" value="${GridRichTextEditor}"/>
		<!---
			@keywords private
			Use "cmc/foundation/ColumnRichTextEditor" to create Column Editor editor.
		-->
		<variable name="columnEditorClass" value="${ColumnRichTextEditor}"/>
		<!---
			@keywords private
			This method is called by find and replace when it finds the searched for text in a cell in this column
			to apply the visual treatment to said cell.		
			@param cell cmc/foundation/GridCell The cell that contains the match.
			@param number index The index of the match in the cell.
			@param number length The length of the match in the cell. 
		-->
		<method args="cell, index, length" name="highlightWordInCell">
			<![CDATA[
			if (cell.editor) {
				cell.editor.highlightWord(index, length);
			}
			]]>
		</method>
		<!---
			@keywords private
			This method is called by find and replace when it wants to undo the visual treatment it did for find and 
			replace.			
			@param cell cmc/foundation/GridCell The cell to remove the formatting from.			
		-->		
		<method args="cell" name="unhighlightCell">
			<![CDATA[
			if (cell.editor) {
				cell.editor.unhighlight();
			}
			]]>
		</method>	
	</GridColumn>
	
	<!---
		@keywords final
		This class defines a grid column that shows the display name for each row object.
		Object display names are derived from the object property declared using the
		"displayNameProperty" attribute in the object's {@link cmc/foundation/ObjectDefinition}.

		If the "showLongDisplayName" attribute is set to "true", the "longDisplayNameProperty"
		attribute in the object's {@link cmc/foundation/ObjectDefinition} will be used for display.
		
		Cells in this column cannot be changed to edit mode. cmc/foundation/GridDisplayName instances can only be
		declared as immediate children of instances of {@link cmc/foundation/ObjectGrid}.
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridDisplayName.
		The column will show the display names for the parent objects of the row objects.
		
		@START_CODE
		<GridDisplayName
			name="campaign"
			parentObject="true"
			text="${resourceBundle.campaign}"
			width="150"/>
		@END_CODE
	-->
	<GridColumn classDefinition="true" definitionName="cmc/foundation/GridDisplayName" editable="false">
		<dependency localName="GridDisplayNameViewer" moduleName="cmc/foundation/GridDisplayNameViewer"/>
		<!---
			@keywords private
		 	Use "cmc/foundation/GridDisplayNameViewer" to create cell viewer instances.
		-->
		<variable name="cellViewerClass" value="${GridDisplayNameViewer}"/>
		<!---
			Set this attribute to "true" to show the display name for the row object's parent object. The default is
			"false" which indicates that the display name should be taken directly from the row object.
		-->
		<variable name="parentObject" type="boolean" value="false"/>
		<!---
			Qualifies the search for the parent object to those primary objects with the
			specified object type or object group.  Used only when the <code>parentObject="true"</code>.
		-->
		<variable name="parentType" type="string" value="${null}"/>

		<!---
			Set this attribute to "true" to display the <code>longDisplayNameProperty</code> for each row object.
			The default is "false" which indicates that the <code>displayNameProperty</code> name will be shown.
		-->
		<variable name="showLongDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "true" to display the object definition <code>displayName</code> for each row object.
			The default is "false".
		-->
		<variable name="showObjectDefinitionDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "false" to indicate that the referenced object should not be resolved before
			calculating the display name.
			The default is "true".
		-->
		<variable name="resolveReferencedObject" type="boolean" value="true"/>

		<!---
			@keywords private
			This method returns the viewer initialization arguments.
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return {
				parentObject: this.parentObject,
				parentType: this.parentType,
				showLongDisplayName: this.showLongDisplayName,
				showObjectDefinitionDisplayName: this.showObjectDefinitionDisplayName,
				resolveReferencedObject: this.resolveReferencedObject
			};
			]]>
		</method>
		
		<!---
			@keywords private
			Get the column filter display value.
			@param cmc/foundation/ModelObject o: the model object instance
		-->
		<method args="o" name="getColumnFilterDisplayValue">
			<![CDATA[
			var displayValue = null;
			if (o && o.objectDefinition) {
				if (this.resolveReferencedObject) {
					o = o.getReferencedObject();
				}
				if (this.parentObject) {
					o = o.getParentPrimaryObject(this.parentType);
				}
				if (o) {
					if (this.showObjectDefinitionDisplayName) {
						displayValue = o.objectDefinition.displayName;
					}
					else {
						displayValue = o.objectDisplayName;
					}
				}
			}
			return displayValue;
			]]>
		</method>
		
		<!---
			@keywords private
			Register a delegate to be executed when the resolved value changes
			for the specified model object.
			@param cmc/foundation/ModelObject o: the model object
			@param cmc/foundation/EventHandler del: the delegate
		-->
		<method args="o, del" name="registerDelegate">
			<![CDATA[
			if (o && o.objectDefinition) {
				if (this.resolveReferencedObject) {
					o = o.getReferencedObject();
				}
				if (this.parentObject) {
					o = o.getParentPrimaryObject(this.parentType);
				}
				if (o) {
					if (this.showObjectDefinitionDisplayName) {
						del.connect(o.objectDefinition, "ondisplayName");
					}
					else {
						del.connect(o, "onobjectDisplayName");
					}
				}
			}
			]]>
		</method>
		
	</GridColumn>

	<!---
		@keywords final
		Use this class to show the object display name in a grid cell. Use this class instead of
		cmc/foundation/GridDisplayName if you need to show display names for some rows and something else for
		other rows.
	-->
	<GridCellDescriptor classDefinition="true" definitionName="cmc/foundation/GridDisplayNameCellDescriptor">
		<dependency localName="GridDisplayNameViewer" moduleName="cmc/foundation/GridDisplayNameViewer"/>
		<!---
			@keywords private
		 	Use "cmc/foundation/GridDisplayNameViewer" to create cell viewer instances.
		-->
		<variable name="cellViewerClass" value="${GridDisplayNameViewer}"/>
		<!---
			Set this attribute to "true" to show the display name for the row object's parent object. The default is
			"false" which indicates that the display name should be taken directly from the row object.
		-->
		<variable name="parentObject" type="boolean" value="false"/>
		<!---
			Qualifies the search for the parent object to those primary objects with the
			specified object type or object group.  Used only when the <code>parentObject="true"</code>.
		-->
		<variable name="parentType" type="string" value="${null}"/>

		<!---
			Set this attribute to "true" to display the <code>longDisplayNameProperty</code> for each row object.
			The default is "false" which indicates that the <code>displayNameProperty</code> name will be shown.
		-->
		<variable name="showLongDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "true" to display the object definition <code>displayName</code> for each row object.
			The default is "false".
		-->
		<variable name="showObjectDefinitionDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "false" to indicate that the referenced object should not be resolved before
			calculating the display name.
			The default is "true".
		-->
		<variable name="resolveReferencedObject" type="boolean" value="true"/>

		<!---
			@keywords private
			This method returns the viewer initialization arguments.
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return {
				parentObject: this.parentObject,
				parentType: this.parentType,
				showLongDisplayName: this.showLongDisplayName,
				showObjectDefinitionDisplayName: this.showObjectDefinitionDisplayName,
				resolveReferencedObject: this.resolveReferencedObject
			};
			]]>
		</method>
		
		<!---
			@keywords private
			Get the column filter display value.
			@param cmc/foundation/ModelObject o: the model object instance
		-->
		<method args="o" name="getColumnFilterDisplayValue">
			<![CDATA[
			var displayValue = null;
			if (o && o.objectDefinition) {
				if (this.resolveReferencedObject) {
					o = o.getReferencedObject();
				}
				if (this.parentObject) {
					o = o.getParentPrimaryObject(this.parentType);
				}
				if (o) {
					if (this.showObjectDefinitionDisplayName) {
						displayValue = o.objectDefinition.displayName;
					}
					else {
						displayValue = o.objectDisplayName;
					}
				}
			}
			return displayValue;
			]]>
		</method>
	</GridCellDescriptor>

	<!---
		@keywords final
		This class defines a grid column that shows object type icons for each row object.
		The icon resource is derived from the "icon" attribute of the
		row object's {@link cmc/foundation/ObjectDefinition}.
		Cells in this column cannot be changed to edit mode. cmc/foundation/GridIconTypeImage instances may only be
		declared as immediate children of instances of {@link cmc/foundation/ObjectGrid}.
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridIconTypeImage.
		
		@START_CODE
		<GridIconTypeImage
			text="${resourceBundle.catalogGroupType_ColumnHeader}"
			visible="true"
			required="true"
			width="60"/>
		@END_CODE
	-->
	<GridColumn alignment="center" classDefinition="true" definitionName="cmc/foundation/GridIconTypeImage" editable="false">
		<dependency localName="GridTypeImageViewer" moduleName="cmc/foundation/GridTypeImageViewer"/>
		<!---
			@keywords private
			Use "cmc/foundation/GridTypeImageViewer" to create instances of this column's viewer.
		-->
		<variable name="cellViewerClass" value="${GridTypeImageViewer}"/>
		
		<!---
			@keywords private
			Get the column filter display value.
			@param cmc/foundation/ModelObject o: the model object instance
		-->
		<method args="o" name="getColumnFilterDisplayValue">
			<![CDATA[
			if (o) {
				return o.getReferencedObject().objectDefinition.displayName;
			}
			else {
				return null;
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Register a delegate to be executed when the resolved value changes
			for the specified model object.
			@param cmc/foundation/ModelObject o: the model object
			@param cmc/foundation/EventHandler del: the delegate
		-->
		<method args="o, del" name="registerDelegate">
			<![CDATA[

			]]>
		</method>
		
	</GridColumn>
	
	<!---
		@keywords private
		
		Text box viewer class for internal use by {@link cmc/foundation/GridText} to display a property value text and will be
		displayed while the grid is in view mode.
	-->
	<TextComponent classDefinition="true" definitionName="cmc/foundation/GridTextViewer" fgcolor="${this.textColor}" fontstyle="${this.textStyle}" multiline="true" resize="true">
		<dependency localName="RichTextEditorUtil" moduleName="cmc/foundation/RichTextEditorUtil"/>
		<dependency localName="FocusIndicator" moduleName="cmc/foundation/FocusIndicator"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<!--- {@link cmc/foundation/ModelProperty} instance associated with this viewer. -->
		<variable name="property" value="${null}"/>
		<!---
			Indicates that the text should interpreted as HTML.
		-->
		<variable name="html" type="boolean" value="false"/>

		<!---
			@keywords private
			text color
		-->
		<variable name="textColor" type="string" value="${null}"/>
		<!---
			@keywords private
			text style
		-->
		<variable name="textStyle" type="string" value="${null}"/>				
		
		<!--- @keywords private -->
		<handler name="onfocus">
			<![CDATA[
			if (!this.indicator) {
				new FocusIndicator.Class(this, {
					name: "indicator",
					focusableView: this,
					indicatorView: this
				});
			}
			]]>
		</handler>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this.updateValueDel) {
				this.updateValueDel.disconnectAll();
				delete this.updateValueDel;
			}
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			Set the {@link cmc/foundation/ModelProperty} to be associated with this text box. Listeners are created to
			watch the property value. If the property changes at anytime, the updateValue method will be called.
			@param cmc/foundation/ModelProperty newProperty: New Property associated with this text box
		-->
		<method args="newProperty" name="setProperty">
			<![CDATA[
			if (typeof (this.property) == "undefined" || newProperty != this.property) {
				if (typeof (this.updateValueDel) == "undefined") {
					this.updateValueDel = new EventHandler.Class(this, "updateValue");
				}
				this.updateValueDel.disconnectAll();
				this.property = newProperty;
				if (this.property) {
					this.updateValueDel.connect(this.property, "onvalue");
					this.updateValue();
				}
			}
			]]>
		</method>

		<!---
			Update and refresh cmc/foundation/GridTextViewer value with a new {@link cmc/foundation/ModelProperty} value.			
		-->
		<method args="e" name="updateValue">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var newText = this.parent.column.getCellText(this.property.o, this.property);
			if (!this.html) {
				newText = this.escapeText(newText);
			}
			else {
				newText = RichTextEditorUtil.Singleton.removeTags(newText);
			}
			if (this.text != newText) {
				this.setVariable("text", newText);
			}
			]]>
		</method>
		
		<Layout name="viewerLayout">
			<!--- @keywords private -->
			<method name="init">
				<![CDATA[
				this.inherited(arguments);
				this.updateHandler.connect(this.parent.immediateParent, "onavailableWidth");
				this.updateHandler.connect(this.parent, "ontext");
				]]>
			</method>
			
			<!---
				@keywords private
				Update the cell layout.
			-->
			<method args="e" name="update">
				<![CDATA[
				if (typeof(e) == "undefined") e = null;
				if (!this.locked) {
					this.lock();
					var newWidth = this.parent.getTextWidth() + 1;
					var availableWidth = this.parent.immediateParent.availableWidth;
					if (availableWidth < 75) {
						availableWidth = 75;
					}
					if (newWidth > availableWidth) {
						newWidth = availableWidth;
					}
					if (this.parent.width != newWidth) {
						this.parent.setVariable("width", newWidth);
					}
					this.locked = false;
				}
				]]>
			</method>
		</Layout>
		<method args="property" name="set_property">
			<![CDATA[
			this.setProperty(property);
			]]>
		</method>
	</TextComponent>
	
	<!---
		@keywords private
		
		This class overrides the <code>updateValue</code> method in the {@link cmc/foundation/TextViewer} class.
	-->
	<GridTextViewer classDefinition="true" definitionName="cmc/foundation/GridStoreNameViewer">
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="StoreUtil" moduleName="cmc/foundation/StoreUtil"/>
		<!---	
			@keywords private
		-->
		<variable name="storeId" type="string" value=""/>
				
		<!---
			@keywords private
			Updates and refreshes the storeId with a new {@link cmc/foundation/ModelProperty} value.
		-->
		<method args="e" name="updateValue">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var storeId = this.property.value;
			if (storeId != this.storeId) {
				this.storeId = storeId;
				this.updateStoreName();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates and refreshes the text value by resolving the store name with a new storeId.
		-->
		<method args="e" name="updateStoreName">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (typeof (this.updateStoreNameDel) == "undefined") {
				this.updateStoreNameDel = new EventHandler.Class(this, "updateStoreName");
			}
			this.updateStoreNameDel.disconnectAll();
			if (this.storeId == '') {
				this.setVariable('text', '');
			}
			else {
				var store = StoreUtil.Singleton.storeMap[this.storeId];
				if (store != null) {
					this.setVariable('text', store.displayName);
				}
				else {
					this.updateStoreNameDel.connect(StoreUtil.Singleton, "storeLoaded");
				}
			}
			]]>
		</method>

		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this.updateStoreNameDel) {
				this.updateStoreNameDel.disconnectAll();
				delete this.updateStoreNameDel;
			}
			this.inherited(arguments);
			]]>
		</method>
	</GridTextViewer>
	
	<!---
		@keywords final
		This class defines a grid column that shows the store name for each row object.
		The store name for an object is the name of the store that matches the store ID found
		in the object property named "objectStoreId".
		Cells in this column cannot be changed to edit mode. cmc/foundation/GridStoreName instances can only be
		declared as immediate children of instances of {@link cmc/foundation/ObjectGrid}.
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridStoreName.
		
		@START_CODE
		<GridStoreName name="storeName"/>
		@END_CODE
	-->
	<GridColumn classDefinition="true" definitionName="cmc/foundation/GridStoreName" editable="false" enableFilter="true" propertyName="objectStoreId" text="${foundationResources.Singleton.objectProperties_storeName.string}" width="150">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="AssetInfoStoreTypesCondition" moduleName="cmc/foundation/AssetInfoStoreTypesCondition"/>
		<dependency localName="StoreUtil" moduleName="cmc/foundation/StoreUtil"/>
		<dependency localName="DefinitionUtil" moduleName="cmc/foundation/DefinitionUtil"/>
		<dependency localName="GridStoreNameViewer" moduleName="cmc/foundation/GridStoreNameViewer"/>
		<!---
			@keywords private
		 	Use "cmc/foundation/GridDisplayNameViewer" to create cell viewer instances.
		-->
		<variable name="cellViewerClass" value="${GridStoreNameViewer}"/>
		<!---
		When this value is <code>false</code>, this column is only visible when working in an extended site and not
		in any other store model types. When this value is <code>true</code>, this column is always visible regardless
		of store model type.
	  -->
	  <variable name="alwaysVisible" type="boolean" value="false"/>

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			if (!this.alwaysVisible) {
				DefinitionUtil.createDefinitionInstance(AssetInfoStoreTypesCondition, this);
			}
			this.inherited(arguments);
			]]>
		</method>
		<!---
			@keywords private
			Get the column filter display value.
			@param cmc/foundation/ModelObject o: the model object instance
		-->
		<method args="o" name="getColumnFilterDisplayValue">
			<![CDATA[
			var storeId = this.inherited(arguments);
			if (StoreUtil.Singleton.storeMap[storeId]) {
				return StoreUtil.Singleton.storeMap[storeId].displayName;
			}
			else {
				return null;
			}
			]]>
		</method>
	</GridColumn>

	<!---
		@keywords private
		
		Rich text box viewer class for internal use by {@link cmc/foundation/GridRichText} to display a property value text and will be
		displayed while the grid is in view mode. The text will be displayed as html.
		
		Extends {@link cmc/foundation/GridTextViewer}.
	-->
	<GridTextViewer classDefinition="true" definitionName="cmc/foundation/GridRichTextViewer" html="true"/>
	
	<!---
		@keywords private
		
		Object display name viewer for a grid cell.
	-->
	<GridTextViewer classDefinition="true" definitionName="cmc/foundation/GridDisplayNameViewer">
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<!---
			Set this attribute to "true" to display the <code>longDisplayNameProperty</code> for each  object.
			The default is "false" which indicates that the <code>displayNameProperty</code> name will be shown.
		-->
		<variable name="showLongDisplayName" type="boolean" value="false"/>
		<!---
			Use the parent object to resolve the display name.
		-->
		<variable name="parentObject" type="string" value=""/>
		<!---
			Specify the object type or object group of the parent object that will be used to resolve the display name.
		-->
		<variable name="parentType" type="string" value=""/>
		<!---
			Set this attribute to "true" to display the object definition <code>displayName</code> for each row object.
			The default is "false".
		-->
		<variable name="showObjectDefinitionDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "false" to indicate that the referenced object should not be resolved before
			calculating the display name.
			The default is "true".
		-->
		<variable name="resolveReferencedObject" type="boolean" value="true"/>
		<!---
			The model object instance.
		-->
		<variable name="o" value="${null}"/>		

		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this.updateDisplayNameDel) {
				this.updateDisplayNameDel.disconnectAll();
				delete this.updateDisplayNameDel;
			}
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			Set the new model object.
			@param cmc/foundation/ModelObject newObject: the new object
		-->
		<method args="newObject" name="setModelObject">
			<![CDATA[
			if (typeof (this.o) == "undefined" || this.o != newObject) {
				this.o = newObject;
				this.updateDisplayName();
			}
			]]>
		</method>
		
		<!---
			Update the display text.
		-->
		<method args="e" name="updateDisplayName">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (!this.updateDisplayNameDel) {
				this.updateDisplayNameDel = new EventHandler.Class(this, "updateDisplayName");
			}
			var newDisplayName = "";
			var newTextColor = null;
			var newTextStyle = null;
			this.updateDisplayNameDel.disconnectAll();
			if (this.o != null && this.o.objectDefinition != null) {
				var resolvedObject = this.o;
				if (this.resolveReferencedObject) {
					resolvedObject = this.o.getReferencedObject();
				}
				if (this.parentObject) {
					resolvedObject = resolvedObject.getParentPrimaryObject(this.parentType, this.updateDisplayNameDel);
				}
				if (resolvedObject) {
					if (this.showObjectDefinitionDisplayName) {
						newDisplayName = resolvedObject.objectDefinition.displayName;
						this.updateDisplayNameDel.connect(resolvedObject.objectDefinition, "ondisplayName");
					}
					else {
						if (this.showLongDisplayName) {
							if (resolvedObject.objectLongDisplayName != null) {
								newDisplayName = resolvedObject.objectLongDisplayName;
							}
							this.updateDisplayNameDel.connect(resolvedObject, "onobjectLongDisplayName");
						}
						else {
							if (resolvedObject.objectDisplayName != null) {
								newDisplayName = resolvedObject.objectDisplayName;
							}
							this.updateDisplayNameDel.connect(resolvedObject, "onobjectDisplayName");
						}
					}
					var style = resolvedObject.displayNameStyle;
					if (style != null) {
						newTextColor = style.color;
						if (style.bold && style.italic) {
							newTextStyle = "bolditalic";
						}
						else if (style.bold) {
							newTextStyle = "bold";
						}
						else if (style.italic) {
							newTextStyle = "italic";
						}
					}
				}
			}
			newDisplayName = this.escapeText(newDisplayName);
			if (this.text != newDisplayName) {
				this.setVariable("text", newDisplayName);
			}
			if (this.textColor != newTextColor) {
				this.setVariable("textColor", newTextColor);
			}
			if (this.textStyle != newTextStyle) {
				this.setVariable("textStyle", newTextStyle);
			}
			]]>
		</method>
		
		<method args="newProperty" name="setProperty">
			<![CDATA[

			]]>
		</method>
		<method args="e" name="updateValue">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;

			]]>
		</method>
		<method args="o" name="set_o">
			<![CDATA[
			this.setModelObject(o);
			]]>
		</method>
	</GridTextViewer>
	
	<!---
		@keywords private
		
		Object type icon viewer for a grid cell.
	-->
	<Component classDefinition="true" definitionName="cmc/foundation/GridTypeImageViewer">
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="EventUtil" moduleName="cmc/foundation/EventUtil"/>
		<!---
			Icon resource name.
		-->
		<variable name="icon" value="${null}"/>
		<!---
			Model object instance.
		-->
		<variable name="o" value="${null}"/>		

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.updateTooltip();
			this.updateCurrentImage();
			]]>
		</method>

		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this.updateTooltipDel) {
				this.updateTooltipDel.disconnectAll();
				delete this.updateTooltipDel;
			}
			if (this.updateCurrentImageDel) {
				this.updateCurrentImageDel.disconnectAll();
				delete this.updateCurrentImageDel;
			}
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			@keywords private
			This method updates the current image.
		-->	
		<method args="e" name="updateCurrentImage">
			<![CDATA[
			if (typeof (this.updateCurrentImageDel) == "undefined") {
				this.updateCurrentImageDel = new EventHandler.Class(this, "updateCurrentImage");
			}
			this.updateCurrentImageDel.disconnectAll();
			this.updateCurrentImageDel.connect(this.parent.column, "onvisible");
			if (this.parent.column.visible) {
				this.display.setVariable("currentImage", this.parent.row.selected ? 2 : 1);
				this.updateCurrentImageDel.connect(this.parent.row, "onselected");
			}
			]]>
		</method>

		<!---
			Set the model object instance for this viewer.
			@param cmc/foundation/ModelObject newObject: the new model object instance
		-->
		<method args="newObject" name="setModelObject">
			<![CDATA[
			if (typeof (this.o) == "undefined" || this.o != newObject) {
				this.o = newObject;
				if (this.o) {
					this.setVariable("icon", this.o.getIcon());
				}
				this.updateTooltip();
			}
			]]>
		</method>

		<!---
			Updates the tooltip text.
		-->
		<method args="e" name="updateTooltip">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.display) {
				if (typeof (this.updateTooltipDel) == "undefined") {
					this.updateTooltipDel = new EventHandler.Class(this, "updateTooltip");
				}
				this.updateTooltipDel.disconnectAll();
				var tooltipText = null;
				if (this.o) {
					tooltipText = this.o.getTypeDisplayName(this.updateTooltipDel);
				}
				this.display.tip.setVariable("text", tooltipText);
				this.display.tip.setVariable("enabled", tooltipText != null);
			}
			]]>
		</method>

		<Component clickable="true" imageSet="${this.classroot.icon}" name="display" stretches="both">
			<Tooltip name="tip"/>

			<handler name="onclick">
				<![CDATA[
				EventUtil.trigger(this.parent.parent.parent, "onclick");
				]]>
			</handler>

			<handler name="ondblclick">
				<![CDATA[
				EventUtil.trigger(this.parent.parent.parent, "ondblclick");
				]]>
			</handler>
		</Component>
		<method args="o" name="set_o">
			<![CDATA[
			this.setModelObject(o);
			]]>
		</method>
	</Component>
	
	<!---
		@keywords final
		This class defines a grid column that shows specific image resources based on
		the property value of the cell.	cmc/foundation/GridPropertyImage instances may only be
		declared as immediate children of instances of {@link cmc/foundation/ObjectGrid}. The image
		displayed will be the image specified by the {@link cmc/foundation/PropertyValue#icon} attribute.
		To override an image for one or more values, use the "imageResourceMap" attribute.
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridIconTypeImage. There
		are three possible icons that will be displayed based on the value of the property named
		"sent".
		
		@START_CODE
		<PropertyDefinition propertyName="sent" copyProtected="true">
			<PropertyValue value="0" displayName="${mktMarketingResources.unsent}" icon="emailActivityUnsentIcon"/>
			<PropertyValue value="1" displayName="${mktMarketingResources.sent}" icon="emailActivitySentIcon"/>
			<PropertyValue value="9" displayName="${mktMarketingResources.scheduled}" icon="emailActivityScheduledIcon"/>
		</PropertyDefinition>
		
		...
		
		<GridPropertyImage name="sent" objectPath="Activity/EmailStatistics[uniqueId=1]"
			propertyName="sent" text="${mktMarketingResources.emailSent}" width="100">
			<GridCellDescriptor propertyName="sent" objectType="ChildWebActivity" disabled="true"/>
		</GridPropertyImage>
		@END_CODE
	-->	
	<GridColumn alignment="center" classDefinition="true" definitionName="cmc/foundation/GridPropertyImage" editable="false">
		<dependency localName="GridPropertyImageViewer" moduleName="cmc/foundation/GridPropertyImageViewer"/>
		<!---
			@keywords private
			Use "cmc/foundation/GridPropertyImageViewer" to create instances of this column's viewer.
		-->
		<variable name="cellViewerClass" value="${GridPropertyImageViewer}"/>
		<!---
			A map of property values and images in the form: {value1: "resource1", ... , valueN: "resourceN"}.
			The image found in this map will take precedence over the image found in the {@link cmc/foundation/PropertyValue#icon}
			attribute.
			@type Map
		-->
		<variable name="imageResourceMap" value="${{}}"/>
		<!--- Image to show when value isn't found in the imageResourceMap -->
		<variable name="defaultResource" type="string" value="${null}"/>

		<!---
			@keywords private
			This method returns the viewer initialization arguments.
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return {
				imageResourceMap: this.imageResourceMap,
				defaultResource: this.defaultResource
			};
			]]>
		</method>
	</GridColumn>
	
	<!---
		@keywords private
		
		Viewer class for cmc/foundation/GridPropertyImage which displays the appropriate image depending on the property value.
	-->
	<Component classDefinition="true" definitionName="cmc/foundation/GridPropertyImageViewer">
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="EventUtil" moduleName="cmc/foundation/EventUtil"/>
		<!--- A map of property values and images in the form: {value1: "resource1", ... , valueN: "resourceN"} -->
		<variable name="imageResourceMap" value="${null}"/>
		<!--- Image to show when value isn't found in the imageResourceMap. Default is null and no image is shown. -->
		<variable name="defaultResource" type="string" value="${null}"/>
		<!--- @keywords private -->
		<variable name="icon" type="string" value="${null}"/>
		<!--- cmc/foundation/ModelProperty instance associated with this viewer -->
		<variable name="property" value="${null}"/>	

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.updateIcon();
			]]>
		</method>

		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this.updateIconDel) {
				this.updateIconDel.disconnectAll();
				delete this.updateIconDel;
			}
			if (this.updateTooltipDel) {
				this.updateTooltipDel.disconnectAll();
				delete this.updateTooltipDel;
			}
			this.inherited(arguments);
			]]>
		</method>

		<!---
			Set the property for this viewer.
			@param cmc/foundation/ModelProperty newProperty: the new property instance
		-->
		<method args="newProperty" name="setProperty">
			<![CDATA[
			if (newProperty != this.property) {
				this.property = newProperty;
				this.updateIcon();
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="e" name="updateIcon">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (typeof (this.updateIconDel) == "undefined") {
				this.updateIconDel = new EventHandler.Class(this, "updateIcon");
			}
			this.updateIconDel.disconnectAll();
			var imageResource = null;
			if (this.property != null) {
				var propValue = this.property.value;
				if (this.imageResourceMap != null && this.imageResourceMap[propValue]) {
					imageResource = this.imageResourceMap[propValue];
				}
				if (imageResource == null && this.property.propertyDefinition) {
					var propValueDef = this.property.propertyDefinition.getPropertyValue(this.property, this.updateIconDel);
					if (propValueDef) {
						imageResource = propValueDef.icon;
					}
				}
				this.updateIconDel.connect(this.property, "onvalue");
			}
			if (imageResource == null) {
				imageResource = this.defaultResource;
			}
			if (this.icon != imageResource) {
				this.setVariable("icon", imageResource);
			}
			this.updateTooltip();
			]]>
		</method>

		<!--- @keywords private -->
		<method args="e" name="updateTooltip">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.display) {
				if (typeof (this.updateTooltipDel) == "undefined") {
					this.updateTooltipDel = new EventHandler.Class(this, "updateTooltip");
				}
				this.updateTooltipDel.disconnectAll();
				var tooltipText = null;
				if (this.property && this.property.propertyDefinition) {
					var propertyValue = this.property.propertyDefinition.getPropertyValue(this.property, this.updateTooltipDel);
					if (propertyValue != null) {
						tooltipText = propertyValue.getDisplayName(this.updateTooltipDel);
					}
				}
				this.display.tip.setVariable("text", tooltipText);
				this.display.tip.setVariable("enabled", tooltipText != null);
			}
			]]>
		</method>

		<Component clickable="true" imageSet="${this.classroot.icon}" name="display" stretches="both" visible="${this.classroot.icon ? true : false}" currentImage="${this.classroot.parent.row.selected ? 2 : 1}">
			<Tooltip name="tip"/>

			<handler name="onclick">
				<![CDATA[
				EventUtil.trigger(this.parent.parent.parent, "onclick");
				]]>
			</handler>

			<handler name="ondblclick">
				<![CDATA[
				EventUtil.trigger(this.parent.parent.parent, "ondblclick");
				]]>
			</handler>
		</Component>
		<method args="property" name="set_property">
			<![CDATA[
			this.setProperty(property);
			]]>
		</method>
	</Component>

	<!---
		@keywords private
		
		Text box editor class for internal use by {@link cmc/foundation/GridText} to bind a property to the grid input box and will be
		displayed while the grid is in edit mode. Extends {@link cmc/foundation/PunchOutTextEditor} to handle transition from edit mode to view
		mode with mouse and key navigation.
	-->
	<PunchOutTextEditor classDefinition="true" definitionName="cmc/foundation/GridTextEditor" maximumHeight="${this.immediateParent.maximumHeight}" multiline="true" textAreaHeight="15" inputTextPadding="5" width="${this.immediateParent.availableWidth}">
		<!---
			Indicates that that this editor contains the find and replace highlight.
		-->
		<variable name="highlighted" type="boolean" value="false"/>

		<!---
			@keywords private
			Remove the highlight if the text changes. 
		-->
		<handler name="ontext">
			<![CDATA[
			if (this.highlighted) {
				this.unhighlight();
			}
			]]>
		</handler>

		<!---
			@keywords private
			This method adds the visual treatment for find and replace to the specified text.
			@param number index The index of the match
			@param number length The length of the match
		-->
		<method args="index, length" name="highlightWord">
			<![CDATA[
			this.textEditor.inputText.highliteText(index, index + length);
			this.highlighted = true;
			]]>
		</method>

		<!---
			@keywords private
			This method undoes the visual treatment for find and replace.			
		-->
		<method name="unhighlight">
			<![CDATA[
			this.textEditor.inputText.unhighliteText();
			this.highlighted = false;
			]]>
		</method>
		
		<handler name="onselected" eventSource="this.parent.row">
			<![CDATA[
			if (this.punchOutButton) {
				if (this.punchOutButton.indicator) {
					this.punchOutButton.indicator.setVariable("focusIndicatorColor", this.parent.row.selected ? "#ffffff" : "#000000");
				}
				var image = this.parent.row.selected ? 3 : 1;
				this.punchOutButton.downImage = image;
				this.punchOutButton.overImage = image;
				this.punchOutButton.setVariable("normalImage", image);
			}
			]]>
		</handler>
	</PunchOutTextEditor>

	<!---
		@keywords private
		
		Rich text box editor class for internal use by {@link cmc/foundation/GridRichText} to bind a property to the grid rich input box and will be
		displayed while the grid is in edit mode. Extends {@link cmc/foundation/RichTextEditor} to handle transition from edit mode to view
		mode with mouse and key navigation.
		
		In edit mode, a dialog {@link cmc/foundation/Dialog} named RichTextDialog is opened that contains a {@link cmc/foundation/RichTextEditor} that allows the business
		user to edit the text value.
	-->
	<FocusableComponent classDefinition="true" definitionName="cmc/foundation/GridRichTextEditor" focusable="false" width="${this.immediateParent.availableWidth}">
		<dependency localName="RichTextEditorUtil" moduleName="cmc/foundation/RichTextEditorUtil"/>
		<dependency localName="FocusIndicator" moduleName="cmc/foundation/FocusIndicator"/>
		<dependency localName="ContextUtil" moduleName="cmc/foundation/ContextUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="Timer" moduleName="cmc/foundation/Timer"/>
		<dependency localName="PreferenceManager" moduleName="cmc/shell/PreferenceManager"/>
		<dependency localName="RootComponent" moduleName="cmc/RootComponent"/>	
		<!--- {@link cmc/foundation/ModelProperty} instance associated with this editor. -->
		<variable name="property" value="${null}"/>

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			if (this.parent.menu) {
				this.parent.menu.addView(this);
			}
			else if (this.parent.grid.menu) {
				this.parent.grid.menu.addView(this);
			}
			this.inherited(arguments);
			this.updateValue();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this.updateValueDel) {
				this.updateValueDel.disconnectAll();
				delete this.updateValueDel;
			}
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			Set the {@link cmc/foundation/ModelProperty} to be associated with this text box. Listeners are created to
			watch the property value. If the property changes at anytime, the updateValue method will be called.
			@param cmc/foundation/ModelProperty newProperty: New Property associated with this text box
		-->
		<method args="newProperty" name="setProperty">
			<![CDATA[
			if (typeof (this.property) == "undefined" || newProperty != this.property) {
				if (typeof (this.updateValueDel) == "undefined") {
					this.updateValueDel = new EventHandler.Class(this, "updateValue");
				}
				this.updateValueDel.disconnectAll();
				this.property = newProperty;
				if (this.property) {
					this.updateValueDel.connect(this.property, "onvalue");
					this.updateValue();
				}
			}
			]]>
		</method>

		<!---
			Update and refresh cmc/foundation/GridTextEditor value with a new {@link cmc/foundation/ModelProperty} value.			
		-->
		<method args="e" name="updateValue">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.isinited) {
				var newText = this.parent.column.getCellText(this.property.o, this.property);
				newText = RichTextEditorUtil.Singleton.removeTags(newText);
				if (this.richText.text != newText) {
					this.richText.setVariable("text", newText);
				}
			}
			]]>
		</method>
		
		<handler name="onselected" eventSource="this.parent.row">
			<![CDATA[
			if (this.openDialogButton) {
				if (this.openDialogButton.indicator) {
					this.openDialogButton.indicator.setVariable("focusIndicatorColor", this.parent.row.selected ? "#ffffff" : "#000000");
				}
				var image = this.parent.row.selected ? 3 : 1;
				this.openDialogButton.downImage = image;
				this.openDialogButton.overImage = image;
				this.openDialogButton.setVariable("normalImage", image);
			}
			]]>
		</handler>
		
		<!---
			@keywords private
			This method adds the visual treatment for find and replace to the specified text.
			@param number index The index of the match
			@param number length The length of the match
		-->
		<method args="index, length" name="highlightWord">
			<![CDATA[
			var greyTag = "<FONT COLOR='#9c9c9c'>";
			var highlightTag = "<FONT COLOR='#FF6633'>";
			var closeColorTag = "</FONT>";
			var boldTag = "<B>";
			var closeBoldTag = "</B>";
			var newText = this.richText.text;
			newText = greyTag + newText.substring(0, index) + boldTag + highlightTag + newText.substring(index, index + length) + closeColorTag + closeBoldTag + newText.substring(index + length) + closeColorTag;
			this.richText.setVariable("text", newText);
			]]>
		</method>
		
		<!---
			@keywords private
			This method undoes the visual treatment for find and replace.			
		-->
		<method name="unhighlight">
			<![CDATA[
			this.updateValue(null);
			]]>
		</method>
		
		<!---
			@keywords private
			Return the language object from the rich text editor if it is language sensitive or the store default locale if not
		-->
		<method name="getLanguageObject">
			<![CDATA[
			var langObject = null;
			var storeConfig = ContextUtil.Singleton.findStoreConfig(this.property.o);
			if (storeConfig != null) {
				if (this.property.o.objectDefinition.languageSensitive) {
					langObject = storeConfig.getLanguageById(this.property.o.getPropertyValue("languageId"));
				}
				else {
					langObject = storeConfig.defaultLanguage;
				}
			}
			return langObject;
			]]>
		</method>
		
		<!---
			@keywords private 
		-->
		<method args="e" name="openEditorDialog">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var caller = this;
			require(["cmc/foundation/RichTextDialog"], function(RichTextDialog) {
				RichTextDialog.Singleton.setVariable("gridEditor", caller);
				RichTextDialog.Singleton.openRichTextDialog();
			});
			]]>
		</method>
		
		<AxisLayout axis="x" spacing="0"/>
		
		<TextComponent multiline="true" name="richText" width="${this.parent.width - this.parent.openDialogButton.width}"/>	

		<BaseButton enabled="${this.classroot.enabled}" focusable="true" imageSet="rteGridIcon" name="openDialogButton">
			<!--
				@keyword private
				onclick is fired not only on mouse click but also when a business user hits the enter key.  onkeyup was being called
				after the cmc/fooundation/RichTextDialog was opened and causing the value to be stored even though there was no change.  This
				marked the object as dirty, see d166420.  A cmc/foundation/Timer was added to prevent this.
			-->
			<handler name="onclick">
				<![CDATA[
				if (typeof (this._opendel) === "undefined") {
					this._opendel = new EventHandler.Class(this.classroot, "openEditorDialog");
				}
				Timer.resetTimer(this._opendel, 100);
				]]>
			</handler>
			
			<!--- @keywords private -->
			<method name="destroy">
				<![CDATA[
				if (this._opendel) {
					this._opendel.disconnectAll();
					delete this._opendel;
				}
				this.inherited(arguments);
				]]>
			</method>
			
			<!---
				@keywords private
				Handle focus.
			-->
			<handler name="onfocus">
				<![CDATA[
				if (!this.indicator) {
					new FocusIndicator.Class(this, {
						name: "indicator",
						focusableView: this,
						indicatorView: this,
						focusIndicatorColor: this.classroot.parent.row.selected ? "#ffffff" : "#000000"
					});
				}
				]]>
			</handler>
		</BaseButton>
		<method args="property" name="set_property">
			<![CDATA[
			this.setProperty(property);
			]]>
		</method>
	</FocusableComponent>
	
	<!---
		@keywords private
	-->
	<Dialog contentPaddingBottomSize="0" contentPaddingLeftSize="0" contentPaddingRightSize="0" contentPaddingTopSize="0" definitionName="cmc/foundation/RichTextDialog" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<variable name="gridEditor" value="${null}"/>
		<variable name="originalText" value="${null}"/>
		<variable name="originalDirty" type="boolean" value="false"/>
		<variable name="originalOpenGroupOpen" type="boolean" value="false"/>
		
		<method args="e" name="openRichTextDialog">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.setVariable("title", this.gridEditor.parent.column.displayText);
			this.originalText = this.gridEditor.property.value;
			this.originalDirty = this.gridEditor.property.dirty;
			this.originalOpenGroupOpen = this.gridEditor.property.o.openGroupObject.open;
			this.richTextEditor.setProperty(this.gridEditor.property);
			this.openWindow();
			this.richTextEditor.updateValue();
			]]>
		</method>
		
		<!---
			Set the focus to Text Input field
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			FocusUtil.setFocus(this.richTextEditor.richInputText);
			]]>
		</method>

		<method name="closeWindow">
			<![CDATA[
			if (this.originalText != null) {
				if (this.originalDirty) {
					this.gridEditor.property.change(this.originalText);
				}
				else {
					this.gridEditor.property.restore();
				}
				if (!this.originalOpenGroupOpen) {
					this.gridEditor.property.o.openGroupObject.setVariable("open", false);
				}
			}
			this.inherited(arguments);
			FocusUtil.setFocus(this.gridEditor.openDialogButton);
			this.gridEditor = null;
			this.originalText = null;
			]]>
		</method>

		<method name="handleOk">
			<![CDATA[
			this.originalText = null;
			this.closeWindow();
			]]>
		</method>
		
		<RichTextEditor maximumHeight="400" name="richTextEditor" textAreaHeight="240" width="500"/>
		<Component placement="footer">
			<AxisLayout axis="x" spacing="10"/>	
			<Button text="${foundationResources.Singleton.richTextDialogCancelButton.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button text="${foundationResources.Singleton.richTextDialogOkButton.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleOk();
					]]>
				</handler>
			</Button>
		</Component>	
	 </Dialog>
	 
	<!---
		This class defines a grid column that shows the images found at the URLs
		derived from the values of the properties associated with the cells. If
		an image is not available, then a default image that indicates
		the image could not be found will be displayed.
		Cells in this column cannot be changed to edit mode.
		cmc/foundation/GridImage instances may only be declared as immediate
		children of instances of {@link cmc/foundation/ObjectGrid}.
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridImage.
		The column will display the images found at the URLs derived from the values
		of the property instances named "thumbnail" found
		in the object instances	that are resolved using the object path
		"CatalogGroup/CatalogGroupDescription".
				
		@START_CODE
		<GridImage
			name="thumbnail"
			objectPath="CatalogGroup/CatalogGroupDescription"
			propertyName="tImage"
			text="${resourceBundle.productThumbnail_ColumnHeader}"
			visible="false"
			sortable="false"/>
		@END_CODE
	-->
	<GridColumn alignment="center" classDefinition="true" definitionName="cmc/foundation/GridImage" editable="false" width="80">
		<dependency localName="GridImageViewer" moduleName="cmc/foundation/GridImageViewer"/>
		<!---
			@keywords private
			Use "cmc/foundation/GridImageViewer" to create instances of this column's viewer.
		-->
		<variable name="cellViewerClass" value="${GridImageViewer}"/>
		<!---
			This attribute allows you to specify the maximum width for the images displayed in the column. Images that are wider will be scaled
			down to this width.
		-->
		<variable name="maximumWidth" type="number" value="60"/>
		
		<!---
			This attribute allows you to specify if image tooltip shows along with image displayed in the column.
		-->
		<variable name="showImageToolTip" type="boolean" value="false"/>
		

		<!---
			@keywords private
			This method returns the viewer initialization arguments.
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return {
				maximumWidth: this.maximumWidth,
				showImageToolTip: this.showImageToolTip
			};
			]]>
		</method>
		
		<!---
			Get the image URL for the specified property value. The default implementation returns the unmodified property value.
			Override this method if the property value must be modified before fetching the image.
			@param string value: the property value
			@return string: the image URL
		-->
		<method args="value" name="getImageURL">
			<![CDATA[
			return value;
			]]>
		</method>
	</GridColumn>

	<!---
		@keywords final
		This class defines a grid column that shows formatted date and time
		property values. When a cell in the column changes to edit mode, then the cell
		will be replaced by a date and time picker. cmc/foundation/GridDateTime instances may only
		be declared as immediate children of instances of {@link cmc/foundation/ObjectGrid}.
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridDateTime.
		The column will display the date and time values for the property instances named "startdate"
		found in the row objects.
		
		@START_CODE
		<GridDateTime
			name="startdate"
			propertyName="startdate"
			editable="true"
			text="${mktMarketingResources.startDate}"/>
		@END_CODE
	-->
	<GridColumn classDefinition="true" definitionName="cmc/foundation/GridDateTime" width="135">
		<dependency localName="ColumnDateTimeEditor" moduleName="cmc/foundation/ColumnDateTimeEditor"/>
		<dependency localName="GridDateTimeEditor" moduleName="cmc/foundation/GridDateTimeEditor"/>
		<dependency localName="GridDateTimeViewer" moduleName="cmc/foundation/GridDateTimeViewer"/>
		<!---
			When true, the time of day will default to 23:59:59:999 when the time picker is first enabled.  
			Otherwise start of day is used 00:00:00:001. 
		-->
		<variable name="endOfDay" type="boolean" value="false"/>
		<!---
			@keywords private
			The name of the class whose instance will be used to display the datetime value
			of the associated property. The default is {@link cmc/foundation/GridDateTimeViewer}.
		 -->
		<variable name="cellViewerClass" value="${GridDateTimeViewer}"/>
		
		<!---
			@keywords private
			The name of the class whose instance will be used to edit the datetime value
			of the associated property. The default is {@link cmc/foundation/GridDateTimeEditor}.
		 -->
		<variable name="cellEditorClass" value="${GridDateTimeEditor}"/>
		<!---
			@keywords private
			Use "cmc/foundation/ColumnDateTimeEditor" to create Column Editor editor.
		-->
		<variable name="columnEditorClass" value="${ColumnDateTimeEditor}"/>
		
		<!---
			@keywords private
			This method returns the editor initialization arguments.
		-->					
		<method name="getEditorInitArgs">
			<![CDATA[
			return {
				endOfDay: this.endOfDay
			};
			]]>
		</method>
	</GridColumn>
	
	<!--- @keywords private
	
		  cmc/foundation/DateTimePicker extension for use as an editor in an object grid
	-->
	<DateTimePicker classDefinition="true" definitionName="cmc/foundation/GridDateTimeEditor" showTimeZone="false" useCompactPadding="true" showReverseImage="${this.parent.row.selected}">
		<!--
			Number of pixels added to the right of a column when expanding its width
			to fit this editor. This is used to make the spacing look better.
		-->
		<variable name="columnRightPadding" type="number" value="10"/>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.style = this.parent.style;
			if (this.width > this.parent.column.width - this.columnRightPadding) {
				this.parent.column.setVariable("width", this.width + this.columnRightPadding);
			}
			]]>
		</method>
		
		<!--- @keywords private  -->
		<handler name="onvisible">
			<![CDATA[
			if (this.visible) {
				if (this.width > this.parent.column.width - this.columnRightPadding) {
					this.parent.column.setVariable("width", this.width + this.columnRightPadding);
				}
			}
			]]>
		</handler>			
		
		<!--- @keywords private  -->
		<handler name="onwidth">
			<![CDATA[
			if (this.visible && this.width > this.parent.column.width - this.columnRightPadding) {
				this.parent.column.setVariable("width", this.width + this.columnRightPadding);
			}
			]]>
		</handler>
	</DateTimePicker>
	
	<!--- @keywords private -->
	<GridTextViewer classDefinition="true" definitionName="cmc/foundation/GridDateTimeViewer">
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
		<dependency localName="PreferenceManager" moduleName="cmc/shell/PreferenceManager"/>
		<method name="getDisplayValue">
			<![CDATA[
			return DateUtil.Singleton.formatUI(DateUtil.Singleton.parse(this.property.value, DateUtil.Singleton.DATE_TIME_FORMAT), DateUtil.Singleton.UI_DATE_TIME_FORMAT);
			]]>
		</method>
		
		<method args="e" name="updateValue">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.text != this.getDisplayValue()) {
				this.setVariable("text", this.getDisplayValue());
			}
			]]>
		</method>
		<!---
			@keywords private
			This handler will update the date and time field if the user changes their date format preference
		-->
		<handler args="preference" eventSource="PreferenceManager.Singleton" name="preferenceChanged">
			<![CDATA[
			if ((preference == "CMCDateFormat" || preference == "CMCTimeFormat") && this.property != null && this.property.value) {
				this.updateValue();
			}
			]]>
		</handler>
	</GridTextViewer>

	<!---
		@keywords final
		This class defines a grid column that shows formatted date
		property values. When a cell in the column changes to edit mode, then the cell
		will be replaced by a date picker. cmc/foundation/GridDate instances may only
		be declared as immediate children of instances of {@link cmc/foundation/ObjectGrid}.
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridDate.
		The column will display the date values for the property instances named "startdate"
		found in the row objects.
		
		@START_CODE
		<GridDate
			name="startDate"
			propertyName="startDate"
			editable="false"
			text="${promotionResources.promotionList_startDate}"
			visible="true"
			width="125"/>
		@END_CODE
	-->
	<GridColumn classDefinition="true" definitionName="cmc/foundation/GridDate" width="125">
		<dependency localName="GridDateViewer" moduleName="cmc/foundation/GridDateViewer"/>
		<dependency localName="GridDateEditor" moduleName="cmc/foundation/GridDateEditor"/>
		<dependency localName="ColumnDateEditor" moduleName="cmc/foundation/ColumnDateEditor"/>
		<!--- Indicates whether to ignore the time when saving the date string value. The default value is <code>false</code>. -->
		<variable name="dateOnly" type="boolean" value="false"/>
		<!---
			Indicates whether to use the start or end of the day. When set to <code>true</code>, 23:59:59:999 is saved
			to the server as the end of the day. If set to <code>false</code>, 00:00:00:001 is used as the start of the day.
		-->
		<variable name="endOfDay" type="boolean" value="false"/>
		<!---
			@keywords private
			The name of the class whose instance will be used to display the date value
			of the associated property. The default is {@link cmc/foundation/GridDateViewer}.
		-->
		<variable name="cellViewerClass" value="${GridDateViewer}"/>
		
		<!---
			@keywords private
			The name of the class whose instance will be used to edit the date value
			of the associated property. The default is {@link cmc/foundation/GridDateEditor}.
		-->
		<variable name="cellEditorClass" value="${GridDateEditor}"/>
		<!---
			@keywords private
			Use "cmc/foundation/ColumnDateEditor" to create Column Editor editor.
		-->
		<variable name="columnEditorClass" value="${ColumnDateEditor}"/>
		
		<!---
			@keywords private
			This method returns the editor initialization arguments.
		-->					
		<method name="getEditorInitArgs">
			<![CDATA[
			return {
				dateOnly: this.dateOnly,
				endOfDay: this.endOfDay
			};
			]]>
		</method>
	</GridColumn>
	
	<!---
		@keywords private
		
		cmc/foundation/DatePicker extension for use as an editor in an object grid
	-->
	<DatePicker classDefinition="true" definitionName="cmc/foundation/GridDateEditor" useCompactPadding="true" showReverseImage="${this.parent.row.selected}">
		<!--
			Number of pixels added to the right of a column when expanding its width
			to fit this editor. This is used to make the spacing look better.
		 -->
		<variable name="columnRightPadding" type="number" value="10"/>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.style = this.parent.style;
			if (this.width >= this.parent.column.width - this.columnRightPadding) {
				this.parent.column.setVariable("width", this.width + this.columnRightPadding);
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<handler name="onvisible">
			<![CDATA[
			if (this.visible) {
				if (this.width >= this.parent.column.width - this.columnRightPadding) {
					this.parent.column.setVariable("width", this.width + this.columnRightPadding);
				}
			}
			]]>
		</handler>
	</DatePicker>
	
	<!--- @keywords private -->
	<GridDateTimeViewer classDefinition="true" definitionName="cmc/foundation/GridDateViewer">
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
		<method name="getDisplayValue">
			<![CDATA[
			return DateUtil.Singleton.formatUI(DateUtil.Singleton.parse(this.property.value, DateUtil.Singleton.DATE_TIME_FORMAT), DateUtil.Singleton.UI_DATE_FORMAT);
			]]>
		</method>
	</GridDateTimeViewer>
	
	<!---
		@keywords final
		This class defines a grid column that shows a number in bytes converted to kilobytes.
		Cells in this column are not editable. cmc/foundation/GridKilobytes instances may only
		be declared as immediate children of instances of {@link cmc/foundation/ObjectGrid}.
		
		The following example demonstrates the declaration of an instance of cmc/foundation/GridKilobytes.
		The column will display the values for the property instances named "fileSize"
		found in the row objects after converting the value from bytes to kilobytes.
		
		@START_CODE
		<GridKilobytes
			name="fileSize"
			propertyName="fileSize"
			text="${promotionResources.fileSize}"
			visible="true"
			width="125"/>
		@END_CODE
	-->
	<GridText alignment="right" classDefinition="true" datatype="number" definitionName="cmc/foundation/GridKilobytes" editable="false" findable="false" width="125">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<!---
			@keywords private
			The name of the class whose instance is used to edit the value.
			By default, the value is null since the value is not editable.
		-->
		<variable name="cellEditorClass" value="${null}"/>
		<!---
			@keywords private
			This column does not support a column editor.
		-->
		<variable name="columnEditorClass" value="${null}"/>
		<!---
			@keywords private
			This method will format the property value into the display value.
			@param cmc/foundation/ModelObject o The model object instance this cell represents.
			@param cmc/foundation/ModelProperty property The model object property instance that this cell will display.
			@return string The value to be displayed by the cell.
		-->
		<method args="o, property" name="getCellText">
			<![CDATA[
			var text = "";
			if (property.value != null && property.value != "") {
				var sizeInKB = Math.ceil(property.value / 1024);
				text = foundationResources.Singleton.replaceValues("fileUploaderKilobytes", [sizeInKB]);
			}
			return text;
			]]>
		</method>	
	</GridText>
	
	<!--- 
		@keywords private
		This editor is used to edit {@link cmc/foundation/GridText} column
	 -->
	<InputText classDefinition="true" definitionName="cmc/foundation/ColumnTextEditor" maximumHeight="300" width="${this.parent.availableWidth}">
		<!--- 
			@keywords private
			The column being edited by {@link cmc/foundation/ColumnTextEditor} 
		 -->
		<variable name="column" value="${null}"/>
		
		<!--- Selected objects {@link cmc/foundation/ModelObject} in grid -->
		<variable name="selectedObjects" value="${null}"/>
		
		<!--- @keywords private -->
		<method name="getValue">
			<![CDATA[
			return this.getText();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="initialValue" name="resetValue">
			<![CDATA[
			this.setText(initialValue);
			]]>
		</method>
	</InputText>
	
	<!--- 
		@keywords private
		This editor is used to edit {@link cmc/foundation/GridDate} column
	 -->
	<DatePicker classDefinition="true" definitionName="cmc/foundation/ColumnDateEditor">
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
	
		<!--- 
			@keywords private
			The column being edited by {@link cmc/foundation/ColumnDateEditor} 
		 -->
		<variable name="column" value="${null}"/>
		
		<!--- Selected objects {@link cmc/foundation/ModelObject} in grid -->
		<variable name="selectedObjects" value="${null}"/>
		
		<!--- @keywords private -->
		<method name="getValue">
			<![CDATA[
			var dateString = this.getDateString();
			var newDate = this.getDate();
			if (newDate != null) {
				if (this.column.dateOnly) {
					dateString = DateUtil.Singleton.format(newDate, DateUtil.Singleton.DATE_ONLY_FORMAT);
				}
				else {
					dateString = (this.column.endOfDay) ? DateUtil.Singleton.format(newDate, DateUtil.Singleton.DATE_FORMAT_END) : DateUtil.Singleton.format(newDate, DateUtil.Singleton.DATE_FORMAT);
				}
			}
			return dateString;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="initialValue" name="resetValue">
			<![CDATA[
			var newDate = DateUtil.Singleton.parse(initialValue, DateUtil.Singleton.DATE_FORMAT);
			if (newDate != null) {
				this.setDate(newDate);
			}
			else {
				this.setDateString(initialValue);
			}
			]]>
		</method>
	</DatePicker>
	
	<!--- 
		@keywords private
		This editor is used to edit {@link cmc/foundation/GridDateTime} column
	 -->
	<DateTimePicker classDefinition="true" definitionName="cmc/foundation/ColumnDateTimeEditor" endOfDay="${this.column.endOfDay}">
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
	
		<!--- 
			@keywords private
			The column being edited by {@link cmc/foundation/ColumnDateTimeEditor} 
		 -->
		<variable name="column" value="${null}"/>
		
		<!--- Selected objects {@link cmc/foundation/ModelObject} in grid -->
		<variable name="selectedObjects" value="${null}"/>
		
		<!--- @keywords private -->
		<method name="getValue">
			<![CDATA[
			var newValue = this.dpview.datepicker.getDateString();
			var timeString = this.tpview.timepicker.getTimeString();
			if (timeString != "") {
				newValue += " " + timeString;
			}
			var newDateTime = this.getDateTime();
			if (newDateTime != null) {
				newValue = DateUtil.Singleton.format(newDateTime, DateUtil.Singleton.DATE_TIME_FORMAT);
			}
			return newValue;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="initialValue" name="resetValue">
			<![CDATA[
			var newDateTime = DateUtil.Singleton.parse(initialValue, DateUtil.Singleton.DATE_TIME_FORMAT);
			if (newDateTime != null) {
				this.setDateTime(newDateTime);
			}
			else {
				var newDate = null;
				var dateString = "";
				var timeString = "";
				if (initialValue != null && initialValue != "") {
					var delimitPos = initialValue.indexOf(" ");
					dateString = initialValue;
					if (delimitPos != -1) {
						dateString = initialValue.substring(0, delimitPos);
						newDate = DateUtil.Singleton.parse(dateString, DateUtil.Singleton.getDatePreferenceFormat());
						if (newDate != null) {
							timeString = initialValue.substring(delimitPos + 1);
						}
						else {
							dateString = initialValue;
						}
					}
				}
				this.dpview.datepicker.setDateString(dateString);
				this.tpview.timepicker.setTimeString(timeString);
				this.setVariable("hasDate", newDate != null);
			}
			]]>
		</method>
	</DateTimePicker>
	
	<!---
		@keywords final
		<p>This class defines a grid column that is used to show a summary of
		object properties on multiple lines.
		Using this class requires that a cell viewer class be create that extends the {@link cmc/foundation/GridDisplaySummaryViewer} class.
		This class will determine what text to display for each line in the summary.</p>
		
		<p>The following example demonstrates the declaration of an instance of cmc/foundation/GridDisplaySummary.
		The column will show a summary of multiple properties of the row objects.</p>
		
		@START_CODE
		<GridDisplaySummary
			name="pagesAndRulesSummary"
			text="${plmPageLayoutResources.summaryColumnTitle}"
			cellViewerClass="cmc/pagelayout/GridLayoutSummaryViewer"
			visible="true"
			width="200"/>
		@END_CODE
	-->
	<GridColumn classDefinition="true" definitionName="cmc/foundation/GridDisplaySummary" editable="false" sortable="false">
		<!---
			Wrap summary line text. If this is set true, then each line will be wrapped.
			If set to false, each line will not be wrapped and will be truncated with an ellipsis if it does
			not fit the width of the column. Default is true.
		-->
		<variable name="wrapText" type="boolean" value="true"/>
		
		<!---
			@keywords private
			Get the column filter display value.
			@param cmc/foundation/ModelObject o: the model object instance
		-->
		<method args="o" name="getColumnFilterDisplayValue">
			<![CDATA[
			return null;
			]]>
		</method>
		
		<!---
			@keywords private
			This method returns the viewer initialization arguments.
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return {
				wrapText: this.wrapText
			};
			]]>
		</method>
	</GridColumn>
	
	<!---
		@keywords private		
		Object to represent one line of text in the summary view.
	-->
	<FocusableComponent classDefinition="true" definitionName="cmc/foundation/GridDisplaySummaryViewerItem" focusable="false" width="${this.immediateParent.width}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<!---
			@keywords private
			Wrap summary line text.
		-->
		<variable name="wrapText" type="boolean" value="true"/>
		
		<!---
			@keywords private
			Summary line text
		-->
		<variable name="summaryLine" type="string"/>
		
		<!---
			@keywords private
			text color
		-->
		<variable name="textColor" type="string" value="${null}"/>
		<!---
			@keywords private
			text style
		-->
		<variable name="textStyle" type="string" value="${null}"/>
		
		<handler name="onsummaryLine">
			<![CDATA[
			this.textView.updateSummaryTextWidth();
			]]>
		</handler>
		
		<Component name="textView" width="${this.parent.width}">
			<AxisLayout axis="x"/>
			<TextComponent fgcolor="${this.classroot.textColor}" fontstyle="${this.classroot.textStyle}" multiline="${this.classroot.wrapText}" name="summaryText" resize="true" text="${this.classroot.summaryLine}" width="0">
				<handler name="oninit">
					<![CDATA[
					this.parent.updateSummaryTextWidth();
					]]>
				</handler>
			</TextComponent>
			<TextComponent fgcolor="${this.classroot.textColor}" fontstyle="${this.classroot.textStyle}" name="truncationText" text="${foundationResources.Singleton.gridTruncationText.string}" visible="false" width="${this.getTextWidth() + 4}" xoffset="3"/>
			
			<handler name="onwidth">
				<![CDATA[
				this.updateSummaryTextWidth();
				]]>
			</handler>
			
			<method name="updateSummaryTextWidth">
				<![CDATA[
				if (!this.classroot.wrapText) {
					var untruncatedWidth = this.summaryText.getTextWidth();
					if (untruncatedWidth > (this.width - 6)) {
						this.truncationText.setVariable('visible', true);
						this.summaryText.setVariable('width', this.width - 6 - this.truncationText.width);
					}
					else {
						this.truncationText.setVariable('visible', false);
						this.summaryText.setVariable('width', untruncatedWidth);
					}
				}
				else {
					this.truncationText.setVariable('visible', false);
					this.summaryText.setVariable('width', this.width);
				}
				]]>
			</method>
		</Component>
	</FocusableComponent>
	
	<!---
		@keywords abstract
		<p>Base cell viewer class for the {@link cmc/foundation/GridDisplaySummary}.</p>
		
		<p>New classes that extend from this base class must implement the <code>updateDisplaySummary</code> method.
		The method should perform the logic required to determine the appropriate summary text
		lines for the business user.
		The <code>setSummaryText<code> method must be called with the array of
		summary text lines before the <code>updateDisplaySummary</code> method completes.</p>

		<p>Any number of child instances of {@link cmc/foundation/FlowSummaryParam} can be created to reference child objects
		or properties of the row object. The <code>updateDisplaySummary</code> method can then obtain the values
		from the <code>{@link cmc/foundation/GridDisplaySummaryViewer#resolvedParams resolvedParams}</code> map referencing the
		<code>cmc/foundation/FlowSummaryParam</code> by name.</p>
		
		<p>For an example implementation see {@link cmc/pagelayout/GridLayoutSummaryViewer}</p> 
		
		<p>Implementations should not be instantiated directly. It should be specified in
		the cellViewerClass attribute of a {@link cmc/foundation/GridDisplaySummary object definition}.</p>
		
	-->
	<FocusableComponent classDefinition="true" definitionName="cmc/foundation/GridDisplaySummaryViewer" focusable="false" width="${this.immediateParent.width}">
		<dependency localName="GridDisplaySummaryViewerItem" moduleName="cmc/foundation/GridDisplaySummaryViewerItem"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<!---
			Wrap summary line text. If this is set true, then each line will be wrapped.
			If set to false, each line will be truncated with an ellipsis if it does
			not fit the width of the column. Default is true.
		-->
		<variable name="wrapText" type="boolean" value="true"/>
		
		<!---
			The model object instance.
		-->
		<variable name="o" value="${null}"/>
		
		<!---
			@keywords private
			Array of {@link cmc/foundation/FlowSummaryParams} for use in creating the summary lines.
		-->
		<variable name="summaryParams" value="${[]}"/>
		
		<!---
			Map containing the resolved values of the defined child {@link cmc/foundation/FlowSummaryParam summary parameters}.
			The key of the map is based on the name of the summary parameter. The value will be a string if the
			parameter resolves to one value. Otherwise, the value will be an array of strings.
		-->
		<variable name="resolvedParams" value="${{}}"/>
		
		<!---
			Delegate that calls {@link cmc/foundation/GridDisplaySummaryViewer#updateDisplaySummary}. Implementations of this
			class may register any events to this delegate if the summary text needs to be refreshed
			when the event occurs.
		-->
		<variable name="updateDisplaySummaryDel"/>
		
		<!---
			@keywords private
			The array of summary lines.
		-->
		<variable name="summaryLines" value="${[]}"/>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			if (typeof (this.updateDisplaySummaryDel) == 'undefined') {
				this.updateDisplaySummaryDel = new EventHandler.Class(this, 'updateDisplaySummary');
			}
			this.resolveAndUpdateSummaryDel = new EventHandler.Class(this, "resolveAndUpdateSummary");
			this.resolveAndUpdateSummary();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.resolveAndUpdateSummaryDel.disconnectAll();
			delete this.resolveAndUpdateSummaryDel;
			this.updateDisplaySummaryDel.disconnectAll();
			delete this.updateDisplaySummaryDel;
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			Goes through each defined cmc/foundation/FlowSummaryParam and tries to resolve its value
			before calling the <code>updateDisplaySummary</code> method.
			@keywords private
		-->
		<method args="e" name="resolveAndUpdateSummary">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.resolveAndUpdateSummaryDel.disconnectAll();
			this.resolveAndUpdateSummaryDel.connect(this, "ono");
			if (this.summaryParams) {
				if (this.o) {
					for (var i = 0; i < this.summaryParams.length; i++) {
						var param = this.summaryParams[i];
						this.resolvedParams[param.name] = param.getValues(this.o, false, this.resolveAndUpdateSummaryDel);
					}
					if (this.summaryList) {
						this.updateDisplaySummary();
					}
				}
				else {
					this.resolvedParams = {};
				}
			}
			]]>
		</method>
		
		<!---
			Returns a string of resolved values for the specified summary parameter. The values are obtained from
			the {@link cmc/foundation/FlowElementSummary#resolvedParams resolvedParams} map.
			
			@param String param The name of the {@link cmc/foundation/FlowSummaryParam summary parameter}
			@return Array If the summary parameter is resolved, the values are returned.
				An empty array is returned if the summary parameter is unresolved.
		-->
		<method args="param" name="getValuesList">
			<![CDATA[
			var values = [];
			if (this.resolvedParams) {
				var value = this.resolvedParams[param];
				if (value != null) {
					values = value;
				}
			}
			return values;
			]]>
		</method>
		
		<!---
			This method sets the summary text lines.			
			@param String[] text The array of summary lines to b displayed.
		-->
		<method args="text" name="setSummaryText">
			<![CDATA[
			for (var i = 0; i < this.summaryLines.length; i++) {
				this.summaryLines[i].setVariable("visible", false);
			}
			var item;
			for (var i = 0; i < text.length; i++) {
				if (i < this.summaryLines.length) {
					item = this.summaryLines[i];
					item.setVariable("summaryLine", text[i]);
					item.setVariable("visible", true);
				}
				else {
					var item = new GridDisplaySummaryViewerItem.Class(this.summaryList, {
						summaryLine: text[i],
						wrapText: this.wrapText
					});
					this.summaryLines.push(item);
				}
			}
			]]>
		</method>
		
		<!---
			Override this method to set summary text.
			This method is called when the defined properties on the
			object have changed or when the object's child objects are updated.
			This method should call setSummaryText to update the text.
			@param Object e An object passed by the event system. This value should be ignored.
		-->
		<method args="e" name="updateDisplaySummary">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;

			]]>
		</method>
		
		<Component name="summaryList" width="${this.parent.width - 5}">
			<AxisLayout axis="y" spacing="5"/>
		</Component>
	</FocusableComponent>
</Definitions>