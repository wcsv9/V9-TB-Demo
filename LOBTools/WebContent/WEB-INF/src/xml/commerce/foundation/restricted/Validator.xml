<?xml version="1.0" encoding="UTF-8"?>

<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<Definitions>

	<!---
		<p>This is the base class of client-side validators. A validator 
		performs client-side validation on changes to object or object properties.
		There are two levels of validation, object level and property level. A validator
		is of property level if it validates values specific to a certain property. A validator
		is of object level if it validates values specific to a certain object. For example, 
		if a validator performs validation on multiple properties in a model object, it should be 
		an object-level validator. An object-level validator must be declared as an immediate 
		sub-node of an instance of {@link cmc/foundation/ObjectDefinition}. A property-level validator must be declared
		as an immediate sub-node of an instance of {@link cmc/foundation/PropertyDefinition}.</p>
		
		<p>A single instance of {@link cmc/foundation/EnablementCondition} can be declared as the child of a validator.
		If the enablement condition evaluates to <code>true</code>, then the validation will be run.
		If the enablement condition evaluates to <code>false</code>, no validation will occur.</p> 
	-->
	<Node classDefinition="true" definitionName="cmc/foundation/Validator">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<!---  An unique identifier string for this validator within a node. -->
		<variable name="validatorId" type="string" value=""/>
		
		<!---
			@keywords private
			the default resource bundle of validation error
		-->
		<variable name="resourceBundle" value="${foundationResources.Singleton}"/>
		
		<!--- 
			The type of this validator. Other objects and widgets can 
			use this type to associate itself with a certain number of validators. 
			This is useful for widgets to decide which validators' errors will 
			be displayed. For example, the following reference editor instance
			will display error messages generated by the validator that has type
			requiredParentCatalogValidator
			
			@START_CODE
				<ReferenceEditor
					promptText="${catalogResources.parentInMasterCatalogPrompt}"
					headerText="${catalogResources.codePrompt}"
					parentObjectTypes="CatalogGroup,Catalog"
					required="true"
					referenceObjectTypes="ChildCatalogGroup"
					allowCreate="false"
					validatorTypes="requiredParentCatalogValidator"/>
			@END_CODE
			
		-->
		<variable name="validatorType" type="string" value=""/>
		
		<!--- 
			<p>Performs validation on the specified model object or changed property. 
			Errors may be logged by calling addValidationErrror on the object or on a specific 
			property. This method is called when the object or property that this validator
			is associated with is changed. This method is no op. It should be overriden to 
			provide concrete validation logic.</p>
			
			<p>Implementators of this method are responsible for checking the result of
			{@link cmc/foundation/Validator#isEnabled} to ensure it is <code>true</code> before performing
			any validation logic. If the result returned is <code>false</code> any previous validation
			errors should be removed using {@link cmc/foundation/ModelObject#clearValidationError} or
			{@link cmc/foundation/ModelProperty#clearValidationError}.</p>
			
			@see cmc/foundation/ModelObject#addValidationError
			@see cmc/foundation/ModelProperty#addValidationError
			   
			@param cmc/foundation/ModelObject o the model object that is to be validated. 
			@param cmc/foundation/ModelProperty changedProperty the property that is just changed
		-->
		<method args="o, changedProperty" name="validate">
			<![CDATA[
			if (typeof(changedProperty) == "undefined") changedProperty = null;

			]]>
		</method>
		
		<!---
			@keywords private
			Returns the error message of a validation error with the given 
			message key. This is a convenience method that wraps the logic
			of getting message from resource bundle. 
			 
			@param String messageKey the key to the error message in resource bundle. 
			@param Array params an array of parameters that will be replacing the place holders in 
			the error message. The index of a value in this array will be the same as that in the 
			place holder. That is, {i} will be replaced by params[i]. 
			@return an error message corresponding to the message key
			
			@see cmc/foundation/ResourceBundle#replaceValues
		 -->
		<method args="messageKey, params" name="getErrorMessage">
			<![CDATA[
			return this.resourceBundle.replaceValues(messageKey, params);
			]]>
		</method>
		
		<!---  
			@keywords private 
			This method pushes this validator into its immediateparent's attribute, an array named validators. 
			This method should not be overridden, otherwise a validator will not be registered to its parent
			object definition or property definition. 
		-->
		<method name="init">
			<![CDATA[
			var validators = this.immediateParent.validators;
			if (!validators) {
				validators = [];
				this.immediateParent.validators = validators;
			}
			validators.push(this);
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			Specifies whether or not this validator is enabled based on the current value of the
			enablement condition.
			@param cmc/foundation/ModelObject o the model object instance to be checked
			@return boolean <code>true</code> if there is no enablement condition defined. Otherwise the result of the
				enablement condition is returned.
		-->
		<method args="o" name="isEnabled">
			<![CDATA[
			var enabled = true;
			if (this.enablementCondition) {
				enabled = this.enablementCondition.isEnabled(o);
			}
			return enabled;
			]]>
		</method>
	</Node>
	
	<!--- 
		This class is an object-level validator. It validates that an object must have a parent object. 
		If an object to validate does not have a parent object, an error message whose key is requiredParentMissing
		will be added to the object. 
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/RequiredParentValidator">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<!--- 
			The error message associated with the validation error generated by this validator
		 -->
		<variable name="errorMessage" type="string" value="${foundationResources.Singleton.requiredParentMissing.string}"/>
		
		<!--- 
			@keywords private
		 -->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			if (this.hasReferencedParent(o) || !this.isEnabled(o)) {
				o.clearValidationError(this);
			}
			else {
				o.addValidationError(this, this.errorMessage);
			}
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns true if the given model object has a parent object. False otherwise. 
			@param ModelObject o the model object instance to be checked. 
		 -->
		<method args="o" name="hasReferencedParent">
			<![CDATA[
			if (!o.referenceMap) {
				return false;
			}
			for (var key in o.referenceMap) {
				var ref = o.referenceMap[key];
				if (ref.parentObject && !ref.pendingDelete && (ref.objectDefinition.parentReference || ref.objectDefinition.collectionReference) && (!ref.getIsVersionObject() || o.getIsVersionObject())) {
					return true;
				}
			}
			return false;
			]]>
		</method>
	</Validator>

	<!--- 
		An instance of this class validates that an object has a given set of properties, and these properties
		all have their values set. The validation will stop at the first property that is missing
		or does not have its value set. A validation error whose key is requiredPropertyMissing
		will be added to the property. 
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/ObjectPropertiesSetValidator">
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<!--- 
			The list of names of the properties to be checked. The names are separated by 
			comma. This is a required attribute.
		 -->
		<variable name="propertyNames" type="string" value=""/>
		
		<!---
			@keywords private 
			The list of names of the properties to be checked. This attribute will be 
			derived with attribute propertyNames, therefore it should not be 
			updated directly. 
		-->
		<variable name="propertyNameList" value="${[]}"/>
		
		<!--- @keywords private -->
		<handler name="oninit">
			<![CDATA[
			this.updatePropertyNameList();
			]]>
		</handler>
		
		<!--- @keywords private -->
		<handler name="onpropertyNames">
			<![CDATA[
			this.updatePropertyNameList();
			]]>
		</handler>
		
		<!--- 
			@keywords private
			
			Updates the attribute propertyNameList based on the value of the attribute
			propertyNames. 
		 -->
		<method name="updatePropertyNameList">
			<![CDATA[
			this.propertyNameList = StringUtil.Singleton.splitAndTrim(this.propertyNames, ",");
			]]>
		</method>
		
		<!--- 
			@keywords private
		 -->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			var enabled = this.isEnabled(o);
			for (var i = 0; i < this.propertyNameList.length; ++i) {
				var property = o.getProperty(this.propertyNameList[i]);
				if (property) {
					if (enabled && StringUtil.Singleton.isBlankString(property.value)) {
						property.addValidationError(this, this.getErrorMessage("requiredPropertyMissing", [property.propertyDefinition.getDisplayName()]));
						break;
					}
					else {
						property.clearValidationError(this);
					}
				}
			}
			]]>
		</method>
	</Validator>
	
	<!---  
		@keywords private
		This validator syncs the based on version name between the version and the primary object.  The basedOnVersionName property value
		of the primary object will be updated if the user updates the versionName of a version that is currently the based version.   
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/SyncBasedOnVersionValidator">
	
		<!--- @keywords private -->
		<method args="o, changedProperty" name="validate">
			<![CDATA[
			if (typeof(changedProperty) == "undefined") changedProperty = null;
			if (!o || !changedProperty) {
				return;
			}
			if (o.getPropertyValue("isBasedOnVersion") == "true" && o.parentObject.getPropertyValue("basedOnVersionName") != changedProperty.value) {
				var basedOnVersionNameProp = o.parentObject.getProperty("basedOnVersionName");
				basedOnVersionNameProp.setVariable("value", changedProperty.value);
			}
			]]>
		</method>
	</Validator>
	
	<!---
		<p>This is a property level validator that ensures that a property has a value. This validator
		will be added automatically to a property definition if the {@link cmc/foundation/PropertyDefinition#required}
		attribute is set to <code>true</code>. If you need to explicitly include this validator in a property definition,
		then do not specify the <code>required</code> attribute.</p>

		<p>If you need to add an enablement condition to this validator, then you will need to declare it
		explicitly. The following example declares a validator that ensures that the property has a value
		when the "format" property is set to "Sms".</p>
		
		@START_CODE
			<RequiredPropertyValidator validatorId="contentRequiredPropertyValidator">
				<EnablementCondition propertyName="format" enablementValue="Sms"/>
			</RequiredPropertyValidator>
		@END_CODE
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/RequiredPropertyValidator">
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method args="propertyDefinition, value" name="checkPropertyValue">
			<![CDATA[
			var valid = true;
			if (StringUtil.Singleton.isBlankString(value)) {
				valid = false;
			}
			return valid;
			]]>
		</method>
	
		<!--- @keywords private -->
		<method args="o, changedProperty" name="validate">
			<![CDATA[
			if (typeof(changedProperty) == "undefined") changedProperty = null;
			if (!changedProperty) {
				return;
			}
			if (this.isEnabled(o)) {
				var propertyDef = changedProperty.propertyDefinition;
				if (propertyDef) {
					if (StringUtil.Singleton.isBlankString(changedProperty.value)) {
						changedProperty.addValidationError(this, this.getErrorMessage("requiredPropertyMissing", [propertyDef.getDisplayName()]));
						return false;
					}
				}
			}
			changedProperty.clearValidationError(this);
			]]>
		</method>
	</Validator>
	
	<!--- 		
		An instance of this class ensures that at least one of the required child objects exist. Required child objects
		are defined in this validator by specifying the objectPath. This is an object-level validator, therefore it is 
		must be a child of the cmc/foundation/ObjectDefinition class.  If no child object matching the given object path is found, 
		an error message will be added to the object. The following example declares a validator that ensures the model 
		object it belongs to has a child object that matches path ChildCatentry. If validation fails, the given error 
		message will be associated with the validation error. 
		
		@START_CODE
			<RequiredChildObjectValidator 
				validatorId="reqChildValidator" 
				objectPath="ChildCatentry" 
				errorMessage="${mktMarketingResources.noProductsSelected}"/>
		@END_CODE
		
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/RequiredChildObjectValidator">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<!--- 
			The object path that describes required child objects. 
		 -->
		<variable name="objectPath" type="string"/>
		
		<!--- 
			The error message to be added to an object when the object 
			does not have at least one matching child object.
		 -->
		<variable name="errorMessage" type="string" value=""/>
		<!--- 
			The name of a property to be verified in the child object. If this attribute is
			specified, then in addition to checking for an existence of a matching child object, the validator
			will also ensure that the property has has a value. 
		 -->
		<variable name="propertyName" type="string" value="${null}"/>
		
		<!--- 
			@keywords private
		 -->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			if (this.isEnabled(o)) {
				var childObjects = o.getObjects(this.objectPath);
				if (this.propertyName == null) {
					if (childObjects == null || childObjects.length <= 0) {
						o.addValidationError(this, this.errorMessage);
						return;
					}
				}
				else {
					var childDefs = o.objectDefinition.getChildDefinitions(this.objectPath);
					if (childObjects == null || childObjects.length <= 0) {
						o.addValidationError(this, this.getRequiredPropertyMessage(o));
						return;
					}
					for (var i = 0; i < childObjects.length; i++) {
						if (StringUtil.Singleton.isBlankString(childObjects[i].getPropertyValue(this.propertyName))) {
							o.addValidationError(this, this.getRequiredPropertyMessage(o));
							return;
						}
					}
				}
			}
			o.clearValidationError(this);
			]]>
		</method>
		
		<!--- 
			@keywords private
		 -->
		<method args="o" name="getRequiredPropertyMessage">
			<![CDATA[
			var message = this.errorMessage;
			if (message == "") {
				var childDefs = o.objectDefinition.getChildDefinitions(this.objectPath);
				var propertyDefinition = null;
				if (childDefs.length > 0) {
					propertyDefinition = childDefs[0].getPropertyDefinition(o, this.propertyName);
				}
				var propertyDisplayName = propertyDefinition ? propertyDefinition.getDisplayName() : this.propertyName;
				message = foundationResources.Singleton.replaceValues("requiredPropertyMissing", [propertyDisplayName]);
			}
			return message;
			]]>
		</method>

	</Validator>
	
	<!---
		<p>This is an object level validator that ensures that the start date is not after the end date.
		No error will be reported if either the start date or end date are blank.</p>
		
		<p>If the start date and end date properties are not contained within the same object, you must 
		specify the <code>startDateObjectPath</code> and <code>endDateObjectPath</code> attributes so 
		that the validator can resolve those child objects. To ensure that the validator is called when the 
		start date and end date properties change, set {@link cmc/foundation/PropertyDefinition#forceParentValidation} 
		to "true".
				
		<p>The following example declares a validator that checks if the property with name "endDate" contains
		a value that is later than the value in the property with name "startDate".</p>
		
		@START_CODE
			<StartDateEndDateValidator startDatePropertyName="startDate" endDatePropertyName="endDate"/>
		@END_CODE
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/StartDateEndDateValidator">
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
		<!---
			The object path to the object containing {@link cmc/foundation/StartDateEndDateValidator#startDatePropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<variable name="startDateObjectPath" type="string" value=""/>
		<!---
			The name of the property that contains the start date. The default value is "startDate".
		-->
		<variable name="startDatePropertyName" type="string" value="startDate"/>
		<!---
			The object path to the object containing {@link cmc/foundation/StartDateEndDateValidator#endDatePropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<variable name="endDateObjectPath" type="string" value=""/>
		<!---
			The name of the property that contains the end date. The default value is "endDate".
		-->
		<variable name="endDatePropertyName" type="string" value="endDate"/>
		
		<!---
			@keywords private 
		 -->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			if (!o) {
				return;
			}
			var startO = o.getObject(this.startDateObjectPath);
			var endO = o.getObject(this.endDateObjectPath);
			if (startO && endO) {
				var startDateProperty = startO.getProperty(this.startDatePropertyName);
				var endDateProperty = endO.getProperty(this.endDatePropertyName);
				var clearError = true;
				if (this.isEnabled(o)) {
					var startDate = DateUtil.Singleton.parse(startDateProperty.value, DateUtil.Singleton.DATE_TIME_FORMAT);
					var endDate = DateUtil.Singleton.parse(endDateProperty.value, DateUtil.Singleton.DATE_TIME_FORMAT);
					if (startDateProperty.enabled && endDateProperty.enabled && startDate != null && endDate != null && startDate.getTime() > endDate.getTime()) {
						endDateProperty.addValidationError(this, this.getErrorMessage("endDateMustBeAfterStartDate", []));
						clearError = false;
					}
				}
				if (clearError) {
					endDateProperty.clearValidationError(this);
				}
			}
			]]>
		</method>
	</Validator>

	<!--- 
		<p>This is an object level validator that ensures that the start time is not after the end time.
		No error will be reported if either the start time or end time are blank.</p>
		
		<p>If the start date and end date properties are not contained within the same object, you must 
		specify the <code>startTimeObjectPath</code> and <code>endTimeObjectPath</code> attributes so 
		that the validator can resolve those child objects. To ensure that the validator is called when the 
		start time and end time properties change, set {@link cmc/foundation/PropertyDefinition#forceParentValidation} 
		to "true".
		
		<p>The following example declares a validator that checks if the property with name "endTime" contains a value that 
		is later than the value in the property with name "startTime".</p>
		
		@START_CODE
			<StartTimeEndTimeValidator startTimePropertyName="startTime" endTimePropertyName="endTime"/>		
		@END_CODE
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/StartTimeEndTimeValidator">
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
		<!---
			The object path to the object containing {@link cmc/foundation/StartTimeEndTimeValidator#startTimePropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<variable name="startTimeObjectPath" type="string" value=""/>
		<!---
			The name of the property that contains the start time. The default value is "startTime".
		-->
		<variable name="startTimePropertyName" type="string" value="startTime"/>
		<!---
			The object path to the object containing {@link cmc/foundation/StartTimeEndTimeValidator#endTimePropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<variable name="endTimeObjectPath" type="string" value=""/>
		<!---
			The name of the property that contains the end time. The default value is "endTime".
		-->
		<variable name="endTimePropertyName" type="string" value="endTime"/>
		
		<!---
			@keywords private
		 -->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			if (!o) {
				return;
			}
			var startO = o.getObject(this.startTimeObjectPath);
			var endO = o.getObject(this.endTimeObjectPath);
			if (startO && endO) {
				var startTimeProperty = startO.getProperty(this.startTimePropertyName);
				var endTimeProperty = endO.getProperty(this.endTimePropertyName);
				var clearError = true;
				if (this.isEnabled(o)) {
					var startTime = DateUtil.Singleton.parse(startTimeProperty.value, DateUtil.Singleton.TIME_FORMAT);
					var endTime = DateUtil.Singleton.parse(endTimeProperty.value, DateUtil.Singleton.TIME_FORMAT);
					if (startTimeProperty.enabled && endTimeProperty.enabled && startTime != null && endTime != null && startTime.getTime() > endTime.getTime()) {
						endTimeProperty.addValidationError(this, this.getErrorMessage("endTimeMustBeAfterStartTime", []));
						clearError = false;
					}
				}
				if (clearError) {
					endTimeProperty.clearValidationError(this);
				}
			}
			]]>
		</method>
	</Validator>
	
	<!---
		<p>This object level validator ensures that two numeric properties represent a valid range. If both properties
		have values, then it ensures that the start number property is not greater than the end number property.
		No error will be reported if either property is left blank.</p>
		
		<p>If the start number and end number properties are not contained within the same object, you must 
		specify the <code>startNumberObjectPath</code> and <code>endNumberObjectPath</code> attributes so 
		that the validator can resolve those child objects. To ensure that the validator is called when the 
		start number and end number properties change, set {@link cmc/foundation/PropertyDefinition#forceParentValidation} 
		to "true".
	
		<p>The following example demonstrates the declaration of a validator that checks that value entered for the
		"amount1" property is not greater than the value entered for the "amount2" property.</p>
		
		@START_CODE
			<NumberRangeValidator 
				startNumberPropertyName="amount1" 
				endNumberPropertyName="amount2"/>
		@END_CODE
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/NumberRangeValidator">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<!--- 
			The error message to be displayed when the end number property is less than the start number property. 
		 -->
		<variable name="errorMessage" type="string" value="${foundationResources.Singleton.secondValueMustBeGreaterThanFirstValue.string}"/>
		<!---
			The object path to the object containing {@link cmc/foundation/NumberRangeValidator#startNumberPropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<variable name="startNumberObjectPath" type="string" value=""/>
		<!---
			The property name of the property that contains the start number. The default value is "startNumber".
		-->
		<variable name="startNumberPropertyName" type="string" value="startNumber"/>
		<!---
			The object path to the object containing {@link cmc/foundation/NumberRangeValidator#endNumberPropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<variable name="endNumberObjectPath" type="string" value=""/>
		<!---
			The property name of the property that contains the end number. The default value is "endNumber".
		-->
		<variable name="endNumberPropertyName" type="string" value="endNumber"/>
		
		<!---
			@keywords private
		 -->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			if (!o) {
				return;
			}
			var startO = o.getObject(this.startNumberObjectPath);
			var endO = o.getObject(this.endNumberObjectPath);
			if (startO && endO) {
				var startNumberProperty = startO.getProperty(this.startNumberPropertyName);
				var endNumberProperty = endO.getProperty(this.endNumberPropertyName);
				var clearError = true;
				if (this.isEnabled(o)) {
					if (startNumberProperty.enabled && endNumberProperty.enabled && startNumberProperty.value != null && endNumberProperty.value != null && startNumberProperty.value != "" && endNumberProperty.value != "" && Number(startNumberProperty.value) > Number(endNumberProperty.value)) {
						endNumberProperty.addValidationError(this, this.errorMessage);
						clearError = false;
					}
				}
				if (clearError) {
					endNumberProperty.clearValidationError(this);
				}
			}
			]]>
		</method>
	</Validator>
	
	<!--- 
		<p>This is a property level validator that ensures that the length of a property value is less than a specified maximum.
		This validator will be added automatically to a property definition if the {@link cmc/foundation/PropertyDefinition#maximumSize}
		attribute is set. If you need to explicitly include this validator in a property definition,
		then do not specify the <code>maximumSize</code> attribute.</p>

		<p>If you need to add an enablement condition to this validator, then you will need to declare it
		explicitly. The following example declares a validator that ensures that the property value does not exceed 160
		characters when the "format" property is set to "Sms".</p>
		
		@START_CODE
			<PropertySizeValidator maximumSize="160">
				<EnablementCondition conditionId="condition2" propertyName="format" enablementValue="Sms"/>
			</PropertySizeValidator>
		@END_CODE
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/PropertySizeValidator">
		<dependency localName="LangUtil" moduleName="cmc/foundation/LangUtil"/>
		<!---
			The maximum size allowed for the property value. This attribute is required.
		-->
		<variable name="maximumSize" type="number"/>
		
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method args="propertyDefinition, value" name="checkPropertyValue">
			<![CDATA[
			var valid = true;
			var propertySize = LangUtil.Singleton.getUTF8ByteCount(value);
			if (this.maximumSize > 0 && propertySize > this.maximumSize) {
				valid = false;
			}
			return valid;
			]]>
		</method>
	
		<!---
			@keywords private
		-->
		<method args="o, changedProperty" name="validate">
			<![CDATA[
			if (typeof(changedProperty) == "undefined") changedProperty = null;
			if (!o || !changedProperty) {
				return;
			}
			if (this.isEnabled(o)) {
				this.verifyMaximumSizeNotExceeded(changedProperty, this.maximumSize);
			}
			else {
				changedProperty.clearValidationError(this);
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="property, maxSize" name="verifyMaximumSizeNotExceeded">
			<![CDATA[
			var isNotExceeded = true;
			if (property && property.value) {
				var propertyDef = property.propertyDefinition;
				var value = LangUtil.Singleton.getUTF8ByteCount(property.value);
				if (maxSize > 0 && value > maxSize) {
					if (propertyDef.format) {
						property.addValidationError(this, this.getErrorMessage("propertySizeTooLargeWithFormat", [propertyDef.getDisplayName(), maxSize, propertyDef.format]));
					}
					else {
						property.addValidationError(this, this.getErrorMessage("propertySizeTooLarge", [propertyDef.getDisplayName(), maxSize]));
					}
					isNotExceeded = false;
				}
			}
			if (isNotExceeded) {
				property.clearValidationError(this);
			}
			return isNotExceeded;
			]]>
		</method>

	</Validator>
	
	<!--- 
		<p>This is a property level validator that ensures that the decimal places of a property value do not exceed the specified maximum.
		This validator will be added automatically to a property definition if the {@link cmc/foundation/PropertyDefinition#maximumDecimalPlaces}
		attribute is set. </p>

		
		@START_CODE
			<DecimalPlacesValidator maximumDecimalPlaces="5" validatorId="catDecimalValueSizeValidator"/>
		@END_CODE
	 -->
	
	<Validator classDefinition="true" definitionName="cmc/foundation/DecimalPlacesValidator">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<!---
			The maximum decimal places allowed for the property value. 
		-->
		<variable name="maximumDecimalPlaces" type="number"/>
		
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		
		<method args="propertyDefinition, value" name="checkPropertyValue">
			<![CDATA[
			var valid = true;
			var propertyDecimalPlaces = this.getDecimalPlaces(value);
			if (propertyDecimalPlaces > this.maximumDecimalPlaces) {
				valid = false;
			}
			return valid;
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<method args="o, changedProperty" name="validate">
			<![CDATA[
			if (typeof(changedProperty) == "undefined") changedProperty = null;
			if (!o || !changedProperty) {
				return;
			}
			if (this.isEnabled(o)) {
				var message = null;
				var propertyDecimalPlaces = this.getDecimalPlaces(changedProperty.value);
				if (propertyDecimalPlaces > this.maximumDecimalPlaces) {
					message = foundationResources.Singleton.replaceValues("invalidNumberDecimalPlaces", [changedProperty.propertyDefinition.getDisplayName(), this.maximumDecimalPlaces]);
				}
				if (message == null) {
					changedProperty.clearValidationError(this);
				}
				else {
					changedProperty.addValidationError(this, message);
				}
			}
			else {
				changedProperty.clearValidationError(this);
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="value" name="getDecimalPlaces">
			<![CDATA[
			value = StringUtil.Singleton.trim(value);
			if (value.indexOf('.') == -1 || value.length == 0 || !StringUtil.Singleton.isNumber(value)) {
				return -1;
			}
			var skippingTrailingZeros = true;
			var decimalPlaces = 0;
			for (var i = value.length - 1; i >= 0; i--) {
				var c = value.charAt(i);
				if (c == ".") {
					break;
				}
				if (skippingTrailingZeros && value.charAt(i) != "0") {
					skippingTrailingZeros = false;
				}
				if (!skippingTrailingZeros) {
					decimalPlaces++;
				}
			}
			return decimalPlaces;
			]]>
		</method>

	</Validator>
	
	
	
	
		<!---
		<p>This is a property level validator that ensures that the property value 
		does not contain any of the characters specified in the invalidCharacters property.</p>
		
		<p>The following example demonstrates the declaration of a validator that checks that 
		the property value does not contain the specified characters in the "invalidCharacters" attribute.</p>
			
		@START_CODE
			<PropertyStringValidator
				errorMessage="${catalogResources.offerPriceMinimumQuantityWarning}"
				invalidCharacters="&?=#/_ "/>
		@END_CODE
	-->
	<Validator classDefinition="true" definitionName="cmc/foundation/PropertyStringValidator">
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<!--- 
			The characters which needs to be excluded.  If this character appears in the property
			of the object then the error message will appear.
		-->
		<variable name="invalidCharacters" type="string"/>
		
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method args="propertyDefinition, value" name="checkPropertyValue">
			<![CDATA[
			var valid = true;
			if (StringUtil.Singleton.isBlankString(value)) {
				valid = false;
			}
			return valid;
			]]>
		</method>
	
		<!--- 
			@keywords private
		 -->
		<method args="o, changedProperty" name="validate">
			<![CDATA[
			if (typeof(changedProperty) == "undefined") changedProperty = null;
			if (!changedProperty) {
				return;
			}
			if (this.isEnabled(o)) {
				var propertyDef = changedProperty.propertyDefinition;
				if (propertyDef) {
					var value = changedProperty.value;
					for (var j = 0; j < this.invalidCharacters.length; j++) {
						if (this.containsInvalidCharacter(value, this.invalidCharacters.charAt(j))) {
							if (this.invalidCharacters.charAt(j) == " ") {
								changedProperty.addValidationError(this, this.getErrorMessage("invalidBlankCharacter", []));
								return false;
							}
							changedProperty.addValidationError(this, this.getErrorMessage("invalidCharacter", [this.invalidCharacters.charAt(j)]));
							return false;
						}
					}
				}
			}
			changedProperty.clearValidationError(this);
			return true;
			]]>
		</method>
		
		<!---
			@keywords private
		 -->
		<method args="sText, char" name="containsInvalidCharacter">
			<![CDATA[
			return (sText.indexOf(char) != -1);
			]]>
		</method>				
	</Validator>

	
	
	
	<!--- 
		<p>This is a property level validator that ensures that a property value is within the specified range.
		This validator will be added automatically to a property definition if the {@link cmc/foundation/PropertyDefinition#minValue}
		or {@link cmc/foundation/PropertyDefinition#maxValue} attributes are set. If you need to explicitly include this validator in a property definition,
		then do not specify the <code>minValue</code> or <code>maxValue</code> attributes.</p>
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/PropertyRangeValidator">
		<!---
			The minimum allowed value. This attribute is optional.
		-->
		<variable name="minValue" type="number" value="${null}"/>
		
		<!---
			The maximum allowed value. This attribute is optional.
		-->
		<variable name="maxValue" type="number" value="${null}"/>
		
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method args="propertyDefinition, value" name="checkPropertyValue">
			<![CDATA[
			var valid = true;
			if (this.isNumeric(value)) {
				value = parseFloat(value);
				if (this.minValue != null) {
					if (value < parseFloat(this.minValue)) {
						valid = false;
					}
				}
				if (this.maxValue != null) {
					if (value > parseFloat(this.maxValue)) {
						valid = false;
					}
				}
			}
			return valid;
			]]>
		</method>
	
		<!---
			@keywords private
		 -->
		<method args="o, changedProperty" name="validate">
			<![CDATA[
			if (typeof(changedProperty) == "undefined") changedProperty = null;
			if (!o || !changedProperty) {
				return;
			}
			if (this.isEnabled(o)) {
				var verified = true;
				if (this.minValue != null) {
					verified = this.verifyMinRangeNotExceeded(changedProperty, this.minValue);
				}
				if (this.maxValue != null && verified) {
					verified = this.verifyMaxRangeNotExceeded(changedProperty, this.maxValue);
				}
			}
			else {
				changedProperty.clearValidationError(this);
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="property, minValue" name="verifyMinRangeNotExceeded">
			<![CDATA[
			if (!property || !property.value) {
				return true;
			}
			var value = property.value;
			if (this.isNumeric(value) == true) {
				value = parseFloat(value);
				minValue = parseFloat(minValue);
				if (value < minValue) {
					property.addValidationError(this, this.getErrorMessage("propertyValueTooSmall", [property.propertyDefinition.getDisplayName(), minValue]));
					return false;
				}
			}
			property.clearValidationError(this);
			return true;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="property, maxValue" name="verifyMaxRangeNotExceeded">
			<![CDATA[
			if (!property || !property.value) {
				return true;
			}
			var value = property.value;
			if (this.isNumeric(value) == true) {
				value = parseFloat(value);
				maxValue = parseFloat(maxValue);
				if (value > maxValue) {
					property.addValidationError(this, this.getErrorMessage("propertyValueTooLarge", [property.propertyDefinition.getDisplayName(), maxValue]));
					return false;
				}
			}
			property.clearValidationError(this);
			return true;
			]]>
		</method>
		
		<!---
			@keywords private
			Determines if a given piece of text is numeric. 
			@param string sText the text to be checked.
			@return true if the given text is numeric. False otherwise. 
		 -->
		<method args="sText" name="isNumeric">
			<![CDATA[
			var validChars = "0123456789-.$'";
			var isNumber = true;
			for (var i = 0; i < sText.length && isNumber == true; i++) {
				var c = sText.charAt(i);
				if (validChars.indexOf(c) == -1) {
					isNumber = false;
				}
			}
			return isNumber;
			]]>
		</method>		

	</Validator>
	
	<!---  
		@keywords private
		
		This validator is of object level. When a number is entered with number of decimal places more than than the 
		standard of the active currency, a warning message will be triggered to notify the user. Active 
		currency is resolved based on the logic described below:
		1) if attribute "currencyPropertyName" is supplied, the currency is the value from the {@link cmc/foundation/ModelProperty} with that name
		2) if attribute "currencyPropertyName" is provided but it does not return a valid currency, skip validation process
		3) if attribute "currencyPropertyName" is not provided, validate by the store default currency.
		
		Instances of this validator may only be declared as direct children of {@link cmc/foundation/ObjectDefinition}.
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/CurrencyFormatValidator">
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<dependency localName="ContextUtil" moduleName="cmc/foundation/ContextUtil"/>
		<dependency localName="GlobalizationUtil" moduleName="cmc/foundation/GlobalizationUtil"/>
		<!---
			The object path to the object containing {@link cmc/foundation/CurrencyFormatValidator#currencyPropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<variable name="currencyObjectPath" type="string" value=""/>
		<!---
			Indicates that the parent property of the {@link cmc/foundation/CurrencyFormatValidator#currencyPropertyName}
			retrieved must be the parent primary object.  If it is false it returns the immediate parent. 
		-->
		<variable name="resolvePrimaryParent" type="boolean" value="false"/>
		<!-- 
			The name of the {@link cmc/foundation/ModelProperty} that contains the currency code used to validate the monetary value. 
			If no property name is specified, then the store default currency will be used.
		-->
		<variable name="currencyPropertyName" type="string"/>
		<!-- 
			The currency code used to validate the monetary value. This value is ignored if
			<code>currencyPropertyName</code> is specified.
		-->
		<variable name="currencyCode" type="string"/>
		<!-- 
			The name of the {@link cmc/foundation/ModelProperty property} that contains the monetary value to be validated.
			This is a required attribute.
		-->
		<variable name="valuePropertyName" type="string"/>
		
		<!--- @keywords private -->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			var modelPropertyValue = o.getProperty(this.valuePropertyName);
			if (this.isEnabled(o)) {
				var isValid = true;
				var numDecPlaces;
				var val = modelPropertyValue.value;
				var numDecPlaces = this.getNumDecimalPlaces(o);
				if (numDecPlaces != null) {
					var isNum = StringUtil.Singleton.isNumber(val);
					if (isNum) {
						var dec = "";
						var decpos = val.indexOf(".");
						if (decpos >= 0) {
							var zeropos = val.length;
							for (var i = val.length - 1; i > decpos; i--) {
								if (val.charAt(i) == "0") {
									zeropos = i;
								}
								else {
									break;
								}
							}
							if (zeropos < val.length) {
								val = val.substring(0, zeropos);
							}
							dec = val.substring(decpos + 1);
						}
						if (dec.length > numDecPlaces) {
							isValid = false;
						}
					}
				}
				if (!isValid) {
					modelPropertyValue.addValidationError(this, this.getErrorMessage("invalidNumberDecimalPlaces", [modelPropertyValue.propertyDefinition ? modelPropertyValue.propertyDefinition.getDisplayName() : this.valuePropertyName, numDecPlaces]));
					return;
				}
			}
			modelPropertyValue.clearValidationError(this);
			]]>
		</method>
		<!--- @keywords private -->
		<method args="o" name="getNumDecimalPlaces">
			<![CDATA[
			var num = null;
			var currencyCode = null;
			if (this.currencyPropertyName) {
				var currencyO = o;
				if (this.currencyObjectPath && this.currencyObjectPath != "") {
					if (this.resolvePrimaryParent) {
						var topO = o.getParentPrimaryObject();
						if (topO) {
							currencyO = topO.getObject(this.currencyObjectPath);
						}
					}
					else {
						currencyO = o.getObject(this.currencyObjectPath);
					}
				}
				currencyCode = currencyO.getPropertyValue(this.currencyPropertyName);
			}
			else if (this.currencyCode) {
				currencyCode = this.currencyCode;
			}
			else {
				var storeConfig = ContextUtil.Singleton.findStoreConfig(o);
				if (storeConfig != null && storeConfig.defaultCurrency != null) {
					currencyCode = storeConfig.defaultCurrency.currencyCode;
				}
			}
			if (currencyCode != null) {
				num = GlobalizationUtil.Singleton.getCurrencyDecimalPlaces(currencyCode);
			}
			return num;
			]]>
		</method>
	</Validator>
	<!---  
		@keywords private
		
		This validator is of property level. It validates that a given property's value conforms 
		to the type defined the corresponding property definition. If there is no property definition, 
		the validation will not be run. It supports three types: 
		  number: the property value must be of valid decimal number. 
		  integer: the property value must be of valid integer
		  date: the property value must be follow the format cmc/foundation/DateUtil.DATE_FORMAT
		  email: the property value must be a valid e-mail address following RFC822 rules
		  
		if the format of the property value is not valid, an error message
		will be added to the property. 
		
		This validator is already a child of {@link cmc/foundation/PropertyDefinition}
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/PropertyValueTypeValidator">
		<dependency localName="DateUtil" moduleName="cmc/foundation/DateUtil"/>
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method args="propertyDefinition, value" name="checkPropertyValue">
			<![CDATA[
			var valid = true;
			if (value && propertyDefinition.type != "string") {
				switch (propertyDefinition.type) {				
					case "number":
						if (!StringUtil.Singleton.isNumber(value)) {
							valid = false;
						}
						break;
					case "integer":
						if (!StringUtil.Singleton.isInteger(value)) {
							valid = false;
						}
						break;
					case "date":
						if (DateUtil.Singleton.parse(value, DateUtil.Singleton.DATE_FORMAT) == null) {
							valid = false;
						}
						break;
					case "datetime":
						if (DateUtil.Singleton.parse(value, DateUtil.Singleton.DATE_FORMAT) == null) {
							valid = false;
						}
						break;
					case "time":
						if (DateUtil.Singleton.parseFormattedTime(value) == null) {
							valid = false;
						}
						break;
					case "currency":
						if (!StringUtil.Singleton.isNumber(value)) {
							valid = false;
						}
						break;
					case "email":
						if (!this.isValidEmail(value)) {
							valid = false;
						}
						break;
				}
			}
			return valid;
			]]>
		</method>

	
		<!--- @keywords private -->
		<method args="o, changedProperty" name="validate">
			<![CDATA[
			if (typeof(changedProperty) == "undefined") changedProperty = null;
			if (!o || !changedProperty) {
				return;
			}
			if (this.isEnabled(o)) {
				var propertyDef = changedProperty.propertyDefinition;
				if (propertyDef) {
					this.verifyPropertyType(changedProperty, propertyDef.type);
				}
			}
			else {
				changedProperty.clearValidationError(this);
			}
			]]>
		</method>
		 
		<!--- @keywords private -->
		<method args="property, type" name="verifyPropertyType">
			<![CDATA[
			if (property && type != "string") {
				var message = null;
				if (property.value) {
					switch (type) {					
						case "number":
							if (!StringUtil.Singleton.isNumber(property.value)) {
								message = this.getErrorMessage("invalidNumber", [property.propertyDefinition.getDisplayName()]);
							}
							break;
						case "integer":
							if (!StringUtil.Singleton.isInteger(property.value)) {
								message = this.getErrorMessage("invalidInteger", [property.propertyDefinition.getDisplayName()]);
							}
							break;
						case "date":
							if (DateUtil.Singleton.parse(property.value, DateUtil.Singleton.DATE_FORMAT) == null) {
								message = this.getErrorMessage("invalidDate", [property.propertyDefinition.getDisplayName()]);
							}
							break;
						case "datetime":
							if (DateUtil.Singleton.parse(property.value, DateUtil.Singleton.DATE_FORMAT) == null) {
								var delimitPos = property.value.indexOf(" ");
								if (delimitPos != -1 && DateUtil.Singleton.parse(property.value.substring(0, delimitPos), DateUtil.Singleton.getDatePreferenceFormat()) != null) {
									message = this.getErrorMessage("invalidTime", [property.propertyDefinition.getDisplayName()]);
								}
								else {
									message = this.getErrorMessage("invalidDate", [property.propertyDefinition.getDisplayName()]);
								}
							}
							break;
						case "time":
							if (DateUtil.Singleton.parseFormattedTime(property.value) == null) {
								message = this.getErrorMessage("invalidTime", [property.propertyDefinition.getDisplayName()]);
							}
							break;
						case "currency":
							if (!StringUtil.Singleton.isNumber(property.value)) {
								message = this.getErrorMessage("invalidMonetaryValue", [property.propertyDefinition.getDisplayName()]);
							}
							break;
						case "email":
							if (!this.isValidEmail(property.value)) {
								message = this.getErrorMessage("invalidEmailAddress", [property.propertyDefinition.getDisplayName()]);
							}
							break;
					}
				}
				if (message == null) {
					property.clearValidationError(this);
				}
				else {
					property.addValidationError(this, message);
				}
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="str" name="isValidEmail">
			<![CDATA[
			var at = "@";
			var dot = ".";
			var space = " ";
			var idxAt = str.indexOf(at);
			var idxDot = str.indexOf(dot);
			var length = str.length;
			if (idxAt == -1 || idxAt == 0 || idxAt == (length - 1)) {
				return false;
			}
			if (idxDot == -1 || idxDot == 0 || str.substring(length - 1, length) == dot) {
				return false;
			}
			if (str.indexOf(at, idxAt + 1) != -1) {
				return false;
			}
			if (str.substring(idxAt - 1, idxAt) == dot || str.substring(idxAt + 1, idxAt + 2) == dot) {
				return false;
			}
			if (str.indexOf(dot, idxAt + 2) == -1) {
				return false;
			}
			if (str.indexOf(space) != -1) {
				return false;
			}
			return true;
			]]>
		</method>
		
	</Validator>
	<!--- 
		@keywords private
		
		This class is an object-level validator. It validates that an upload file has been selected for a new file object.
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/FileRequiredValidator" validatorType="fileRequiredValidator">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<!--- 
			The error message associated with the validation error generated by this validator when there is no selected file.
		 -->
		<variable name="errorMessage" type="string" value="${foundationResources.Singleton.fileMissing.string}"/>

		<!--- 
			The error message associated with the validation error generated by this validator when the selected file is missing during file uploading or the selected file size is zero.
		 -->
		<variable name="errorMessageForInvalidUploadFile" type="string" value="${foundationResources.Singleton.uploadFileFailed.string}"/>

		<!--- 
			@keywords private
		 -->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			if (!this.isEnabled(o) || (o && (!o.objectDefinition.isFileObject || this.hasFileToUpload(o)))) {
				if (this.isFileSizeZero(o)) {
					o.addValidationError(this, this.errorMessageForInvalidUploadFile);
				}
				else {
					o.clearValidationError(this);
				}
			}
			else {
				o.addValidationError(this, this.errorMessage);
			}
			]]>
		</method>

		<!---
			@keywords private
			This method returns false if the object passed in as an argument is a new object and does not have 
			a file to upload, and returns true otherwise.
		-->
		<method args="o" name="hasFileToUpload">
			<![CDATA[
			var hasFile = true;
			if (o.newObject && (o.fileref == null || typeof (o.fileref.name) == "undefined")) {
				hasFile = false;
			}
			return hasFile;
			]]>
		</method>

		<!---
			@keywords private
			This method returns true if the object passed in as an argument and does have 
			a file to upload but the file size is zero, and returns false otherwise.
		-->
		<method args="o" name="isFileSizeZero">
			<![CDATA[
			var isZeroSize = false;
			if ((o.fileref != null) && (o.fileref.size == 0)) {
				isZeroSize = true;
			}
			return isZeroSize;
			]]>
		</method>
	</Validator>
		
	<!---  
		@keywords private
		
		Default error message view. This view displays a given piece of error message 
		in a colored box with drop shadow. The width of the box is automatically resizable according to 
		the length of the error message. An error message view requires a target view to attach to. 
		The attribute attachTarget is used to specify this view. An error message view will be 
		attached to the position specified by the attribute "attach". 
	 -->
	<BaseWindow allowdrag="false" classDefinition="true" definitionName="cmc/foundation/ErrorMessageView" ignoreLayout="true">
		<dependency localName="CallbackUtil" moduleName="cmc/foundation/CallbackUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="RootComponent" moduleName="cmc/RootComponent"/>
		<!--- The error text to be displayed to users -->
		<variable name="errorMessage" type="string" value=""/>
		
		<!--- True if the message allows multiple lines. False otherwise. -->
		<variable name="multiline" type="boolean" value="true"/>

		<!--- The default opacity of this error message, ranging from 0 to 1. 0 is completely transparent. 1 is complely opaque -->
		<variable name="defaultOpacity" type="number" value="1"/>
		
		<!---  The default duration for showing or hiding animation of this view -->
		<variable name="duration" value="200"/>
		
		<!---  The view to which this message is attached -->
		<variable name="attachTarget" value="${null}"/>
		
		<!---
			@keywords private
			Indicates that the deferred call to the updateLocation method has been added.
		-->
		<variable name="updateLocationCallbackAdded" type="boolean" value="false"/>
						
		<!--- 
			The position where this error message will be attached. Only four values are supported: 
			  top: the message is on top of the attach target, arrow pointing down. 
			  bottom: the attach target is on top of the error message. The message's arrow points up. 
			  left: the attach target is to the left of the attach target, arrow pointing to the left. 
			  right: the attach target is to the right of the attach target, arrow pointing to the right. 
		-->
		<variable name="attach" type="string" value="right"/>
		
		<!--- 
			@keywords private
		 -->
		<method name="destroy">
			<![CDATA[
			if (this.updateLocationDel) {
				this.updateLocationDel.disconnectAll();
				delete this.updateLocationDel;
			}
			if (this.updateLocationCallbackAdded) {
				CallbackUtil.Singleton.cancelCallback(this.updateLocationCallbackDel);
				this.updateLocationCallbackAdded = false;
			}
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			@keywords private
			Adjusts the attach location if attach target is updated. 
		 -->
		<handler name="onattachTarget">
			<![CDATA[
			if (!this.updateLocationDel) {
				this.updateLocationDel = new EventHandler.Class(this, "updateLocation");
			}
			else {
				this.updateLocationDel.disconnectAll();
			}
			if (this.attachTarget != null) {
				this.updateLocationDel.connect(this, "onvisible");
				this.updateLocationDel.connect(this, "onwidth");
				this.updateLocationDel.connect(this, "onheight");
				var v = this.attachTarget;
				while (v != null && v != RootComponent.Singleton) {
					this.updateLocationDel.connect(v, "onx");
					this.updateLocationDel.connect(v, "ony");
					v = v.immediateParent;
				}
				this.updateLocationDel.connect(this.attachTarget, "onwidth");
				this.updateLocationDel.connect(this.attachTarget, "onheight");
				this.updateLocationDel.connect(this.immediateParent, "onwidth");
				this.updateLocationDel.connect(this.immediateParent, "onheight");
				this.updateLocation();
			}
			else {
				this.setVariable("x", -1000);
				this.setVariable("y", -1000);
			}
			]]>
		</handler>
		
		<!--- 
			@keywords private
			@return the x position of this error message if it is attached to the right of the attach target.
		 -->
		<method name="getXForRightAttachment">
			<![CDATA[
			return this.attachTarget.getVariableRelative("x", this.immediateParent) + this.attachTarget.width + 4;
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns the y position of this error message if it is attached to the left or right of the attach target. 
		 -->
		<method name="getYForLeftOrRightAttachment">
			<![CDATA[
			return this.attachTarget.getVariableRelative("y", this.immediateParent) + (this.attachTarget.height - this.height) / 2;
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns the x positionof this error message if it is attached to the top or bottom of the 
			attach target. 
		 -->
		<method name="getXForTopOrBottomAttachment">
			<![CDATA[
			return this.attachTarget.getVariableRelative("x", this.immediateParent);
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns the x position of this error message if it is attached to the left of the attach target. 
		 -->
		<method name="getXForLeftAttachment">
			<![CDATA[
			return this.attachTarget.getVariableRelative("x", this.immediateParent) - this.width - 4;
			]]>
		</method>
		
		
		<!--- 
			@keywords private
			Returns the y position of this error message if it is attached to the top of the attach target. 
		 -->
		<method name="getYForTopAttachment">
			<![CDATA[
			return this.attachTarget.getVariableRelative("y", this.immediateParent) - this.height - 2;
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns the y position of this error message if it is attached to the bottom of the attach 
			target. 
		 -->
		<method name="getYForBottomAttachment">
			<![CDATA[
			return this.attachTarget.getVariableRelative("y", this.immediateParent) + this.attachTarget.height + 2;
			]]>
		</method>
		
		
		<!--- 
			@keywords private
			Returns the valid attach position, starting with this.attach. If all four positions are tried but 
			none is valid, this.attach will be used. A right or left position is valid if the error message will 
			not extend beyond the vertical edges of its parent. A top or bottom position is valid if the error 
			message will not extend beyond the horizontal edges of its parent. If a position is valid, its opposite
			will be tried first. For example, if left is invalid, right will be tried next. 
			
			Modify this method if we need to change the order of searching valid attachment position. The currently
			implemented order is right -> left -> top -> bottom -> right.
		 -->
		<method name="getValidAttach">
			<![CDATA[
			if (!this.attachTarget || !this.attachTarget.visible) {
				return undefined;
			}
			var newAttach = this.attach;
			var count = 0;
			while (true) {
				if (newAttach == "right") {
					var availableWidth = this.immediateParent.width - this.getXForRightAttachment();
					if (availableWidth >= this.width) {
						return newAttach;
					}
					else {
						newAttach = "left";
						count += 1;
					}
				}
				if (newAttach == "left") {
					var availableWidth = this.attachTarget.getVariableRelative("x", this.immediateParent);
					if (availableWidth >= this.width) {
						return newAttach;
					}
					else {
						newAttach = "top";
						count += 1;
					}
				}
				if (newAttach == "bottom") {
					var availableHeight = this.immediateParent.height - this.getYForBottomAttachment();
					if (availableHeight >= this.height) {
						return newAttach;
					}
					else {
						newAttach = "right";
						count += 1;
					}
				}
				if (newAttach == "top") {
					var availableHeight = this.attachTarget.getVariableRelative("y", this.immediateParent);
					if (availableHeight >= this.height) {
						return newAttach;
					}
					else {
						newAttach = "bottom";
						count += 1;
					}
				}
				if (count >= 4) {
					return this.attach;
				}
			}
			]]>
		</method>
		
		<!--- 
			@keywords private
			Add a deferred call back to update location.
		 -->
		<method args="e" name="updateLocation">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (!this.updateLocationCallbackAdded) {
				if (typeof (this.updateLocationCallbackDel) == "undefined") {
					this.updateLocationCallbackDel = new EventHandler.Class(this, "updateLocationCallback");
				}
				this.updateLocationCallbackAdded = true;
				CallbackUtil.Singleton.addDeferredCallback(this.updateLocationCallbackDel, null, CallbackUtil.Singleton.PRIORITY_FOREGROUND);
			}
			]]>
		</method>
		
		<!--- 
			@keywords private
			Updates the location of this error message based on the first found valid attachment position. 
		 -->
		<method args="e" name="updateLocationCallback">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateLocationCallbackAdded = false;
			if (this.attachTarget && this.visible) {
				switch (this.getValidAttach()) {				
					case "right":
						this.setVariable('x', this.getXForRightAttachment());
						this.setVariable('y', this.getYForLeftOrRightAttachment());
						break;
					case "left":
						this.setVariable('x', this.getXForLeftAttachment());
						this.setVariable('y', this.getYForLeftOrRightAttachment());
						break;
					case "bottom":
						this.setVariable('x', this.getXForTopOrBottomAttachment());
						this.setVariable('y', this.getYForBottomAttachment());
						break;
					case "top":
						this.setVariable('x', this.getXForTopOrBottomAttachment());
						this.setVariable('y', this.getYForTopAttachment());
				}
				this.layout.update();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			The layout manager for this error message
		 -->
		<Layout name="layout">			
			<!--- 
				Sets up the x-coordinates of all the views composing the error message area. That is, 
				the arrow is not included. 
				 
				@param Number startX the x position of the top left corner of the message area. 
			 -->
			<method args="startX" name="updateMessageAreaX">
				<![CDATA[
				this.classroot.message.setVariable('x', startX + 10);
				this.classroot.background.setVariable('x', startX);
				this.classroot.background.setVariable('width', this.classroot.message.width + 20);
				]]>
			</method>
			
			<!--- 
				Displays the appropriate arrow based on the given attachment position. 
			 -->
			<method args="attach" name="updateArrowResource">
				<![CDATA[
				var resourceMap = {
					right: 1,
					bottom: 2,
					left: 3,
					top: 4
				};
				this.classroot.arrow.setVariable("currentImage", resourceMap[attach]);
				]]>
			</method>
			
			<!--- 
				Updates the x-cordinates of all the views in this error message, including arrow's. 
			 -->
			<method args="attach" name="updateX">
				<![CDATA[
				switch (attach) {				
					case "right":
						this.classroot.arrow.setVariable('x', 0);
						this.updateMessageAreaX(this.classroot.arrow.width);
						break;
					case "left":
						this.updateMessageAreaX(0);
						this.classroot.arrow.setVariable('x', this.classroot.background.width);
						break;
					default:
						this.updateMessageAreaX(0);
						this.classroot.arrow.setVariable('x', 10);
				}
				]]>
			</method>
			
			<!---
				Updates the y-coordinate of the message area
			 -->
			<method args="startY" name="updateMessageAreaY">
				<![CDATA[
				this.classroot.message.setVariable('y', startY + 6);
				this.classroot.background.setVariable('y', startY);
				this.classroot.background.setVariable('height', this.classroot.message.height + 11);
				]]>
			</method>
			
			<!--- 
				Updates the y-coordinates of the message
			 -->
			<method args="attach" name="updateY">
				<![CDATA[
				switch (attach) {				
					case "bottom":
						this.classroot.arrow.setVariable('y', 0);
						this.updateMessageAreaY(this.classroot.arrow.height);
						break;
					case "top":
						this.updateMessageAreaY(0);
						this.classroot.arrow.setVariable('y', this.classroot.background.height);
						break;
					default:
						this.updateMessageAreaY(0);
						this.classroot.arrow.setVariable('y', (30 - this.classroot.arrow.height) / 2);
				}
				]]>
			</method>
			
			<method args="e" name="update">
				<![CDATA[
				if (typeof(e) == "undefined") e = null;
				if (this.locked == false) {
					this.lock();
					var messageWidth = this.classroot.message.getTextWidth();
					if (messageWidth > 500) {
						messageWidth = 500;
					}
					this.classroot.message.setVariable("width", messageWidth);
					var validAttach = this.classroot.getValidAttach();
					if (validAttach) {
						this.updateArrowResource(validAttach);
						this.updateX(validAttach);
						this.updateY(validAttach);
					}
					this.locked = false;
				}
				]]>
			</method>
		</Layout>
		
		
		<Component bgcolor="#e71d32" name="background">
			<Component bgcolor="#ffe8ee" x="1" y="1" width="${this.parent.width - 2}" height="${this.parent.height - 2}"/>
		</Component>
		
		<TextComponent multiline="${this.parent.multiline}" name="message" text="${this.classroot.errorMessage}"/>

		<Component imageSet="errorMessageArrow" name="arrow"/>
		
		<Animator duration="${this.parent.duration}" from="0" name="showAnimator" start="false" to="${this.parent.defaultOpacity}" variable="opacity"/>
		<!---  somehow animator.setTo(to) doesn't take effect immediately. So, we use two animator to make sure error message always show or hide. -->
		<Animator duration="${this.parent.duration}" from="${this.parent.defaultOpacity}" name="hideAnimator" start="false" to="0" variable="opacity"/>
		<!--- 
			This method shows the given error message with animation .
			@param String message The message that is to be displayed
		 -->
		<method args="message" name="show">
			<![CDATA[
			this.setVariable("errorMessage", message);
			if (!this.showing) {
				this.bringToFront();
				this.setVariable("visible", true);
				this.showAnimator.doStart();
				this.showing = true;
			}
			]]>
		</method>
		
		<!--- 
			This method hides the shown error message if the expected attachment target is the current
			attachTarget or there is no exptected attachment target at all. 
			@param cmc/foundation/Component expectedTarget the expected attachment target. This view will be hiden only 
			if there is no expected target specified, or the expected target is the same as this.attachTarget. 
			We need this because multiple widgets may share the same error message, so we need to ensure an 
			irrelevant widget will not hide this message accidentally. 
		 -->
		<method args="expectedTarget" name="hide">
			<![CDATA[
			if (typeof(expectedTarget) == "undefined") expectedTarget = null;
			if (this.showing && (!expectedTarget || this.attachTarget == expectedTarget)) {
				this.hideAnimator.doStart();
				this.showing = false;
				this.setVariable("visible", false);
			}
			]]>
		</method>
	</BaseWindow>	
	
	<!--- 
		A globally available error message instance. Since at most one error message will be displayed at any 
		given moment, all widgets that needs error message should use this instance. 
	-->
	<ErrorMessageView definitionName="cmc/foundation/ErrorMessage" singletonDefinition="true" visible="false"/>
	
	<!---
		This object level validator ensures that if the current object has any child objects that
		match the specified object path, that at least one of those objects has a property that matches the specified
		property name and property values. In order to ensure that this validator gets called when the
		property value changes, there must be a property definition for the property and it must have
		{@link cmc/foundation/PropertyDefinition#forceParentValidation forceParentValidation} set to "true".
		No error will be displayed if there are no child objects that match the object path.
		The following example demonstrates the declaration of a 
		validator that checks that one of the catalog entry offer prices
		has a minimum quantity set to "1".
		
		@START_CODE
			<RequiredSpecificValueForChildObjectPropertyValidator
				objectPath="CatalogEntryOfferGroup" 
				errorMessage="${catalogResources.offerPriceMinimumQuantityWarning}"
				propertyName="minimumQuantity" 
				propertyValues="1.0,1"/>
		@END_CODE
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/RequiredSpecificValueForChildObjectPropertyValidator">
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<!--- 
			The name of the property which must have a specific value. This is a required attribute.
		-->
		<variable name="propertyName" type="string" value=""/>
		
		<!---
			Comma separated list of property values. This is a required attribute.
		-->
		<variable name="propertyValues" type="string" value=""/>
		
		<!--- 
			The object path that describes the child objects.
		-->
		<variable name="objectPath" type="string"/>
		
		<!---
			If this is set to "true", this validator will ensure any child objects that
			match the specified object path, that none of those objects has a property that
			matches the specified property name and property values. Default value is false.
		-->
		<variable name="negate" type="boolean" value="false"/>
		
		<!---
			The error message to display when no matching property is found.
		-->
		<variable name="errorMessage" type="string" value=""/>
		
		<!---
			@keywords private
		 -->
		<variable name="propertyValueList" value="${[]}"/>
		
		<!--- @keywords private -->
		<handler name="oninit">
			<![CDATA[
			this.updatePropertyValueList();
			]]>
		</handler>
		
		<!--- 
			@keywords private
			Updates the attribute propertyNameList based on the value of the attribute
			propertyNames. 
		 -->
		<method name="updatePropertyValueList">
			<![CDATA[
			this.propertyValueList = StringUtil.Singleton.splitAndTrim(this.propertyValues, ",");
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			if (this.isEnabled(o)) {
				var childObjects = o.getObjects(this.objectPath);
				if (childObjects == null || childObjects.length <= 0) {
					o.clearValidationError(this);
					return;
				}
				for (var i = 0; i < childObjects.length; ++i) {
					var childObject = childObjects[i];
					var propertyValue = childObject.getPropertyValue(this.propertyName);
					for (var j = 0; j < this.propertyValueList.length; ++j) {
						if (propertyValue == this.propertyValueList[j]) {
							if (!this.negate) {
								o.clearValidationError(this);
								return;
							}
							else {
								o.addValidationError(this, this.errorMessage);
								return;
							}
						}
					}
				}
				if (!this.negate) {
					o.addValidationError(this, this.errorMessage);
				}
				else {
					o.clearValidationError(this);
				}
			}
			else {
				o.clearValidationError(this);
			}
			]]>
		</method>
	</Validator>
	
	<!---
		<p>The <code>cmc/foundation/UniqueValueForChildObjectPropertyValidator</code> class is an object level validator. If the selected object has any child objects that match the 
		specified object path, this class ensures that each of these child objects has a unique property value. To call this validator when the property 
		value changes, create a property definition with forceParentValidation set to "true". If multiple child objects match the specified object path 
		and have the same property values, an error message is displayed.
		<p>The following example demonstrates the declaration of a validator that checks that the value of minimumQuantity is unique.
		
		@START_CODE
			<CatalogEntryUniquenessValidator
				package="cat"
				objectPath="CatalogEntryOfferGroup" 
				errorMessage="${catalogResources.uniquenessWarning}"
				propertyName="minimumQuantity"/>
		@END_CODE
	 -->
	<Validator classDefinition="true" definitionName="cmc/foundation/UniqueValueForChildObjectPropertyValidator">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<!--- 
			The name of the property which must have a unique value. This is a required attribute.
		-->
		<variable name="propertyName" type="string" value=""/>			
		<!--- 
			The object path that describes the child objects. This is a required attribute.
		-->
		<variable name="objectPath" type="string"/>		
		<!---
			The error message text to display when the property value is not unique. The message can have two substitution variables denoted 
			by {0} and {1}. {0} is replaced with the property value and {1} is replaced with the display name.
		-->
		<variable name="errorMessage" type="string" value="${foundationResources.Singleton.uniquenessWarning.string}"/>
		
		<!---
			@keywords private
		-->
		<method args="o, property" name="validate">
			<![CDATA[
			if (typeof(property) == "undefined") property = null;
			if (this.isEnabled(o)) {
				var childObjects = o.getObjects(this.objectPath);
				if (childObjects == null || childObjects.length <= 0) {
					return;
				}
				var propMap = {};
				for (var i = 0; i < childObjects.length; ++i) {
					var childObject = childObjects[i];
					var property = childObject.getProperty(this.propertyName);
					var val = property.value;
					var propertyValue = property.propertyDefinition.getPropertyValue(property, null);
					if (propertyValue && propertyValue.getDisplayName(null) != "") {
						val = propertyValue.getDisplayName(null);
					}
					else if (property.propertyDefinition.type == "number") {
						val = parseFloat(val);
					}
					if (propMap[val] != null) {
						var message = StringUtil.Singleton.replaceParams(this.errorMessage, [val, property.propertyDefinition.displayName]);
						property.addValidationError(this, message);
						propMap[val].addValidationError(this, message);
					}
					else {
						property.clearValidationError(this);
						propMap[val] = property;
					}
				}
			}
			]]>
		</method>
	</Validator>
	
</Definitions>